(window.webpackJsonp=window.webpackJsonp||[]).push([[400],{746:function(v,_,e){"use strict";e.r(_);var d=e(4),o=Object(d.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("A quantifier is placed after an atom to repeat it a certain number of times. It cannot appear on its own. Each quantifier is able to specify a minimum and maximum number that a pattern must be repeated for.")]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#一般形式"}},[v._v("一般形式")])]),_("li",[_("a",{attrs:{href:"#常用量词"}},[v._v("常用量词")])]),_("li",[_("a",{attrs:{href:"#点号"}},[v._v("点号")])]),_("li",[_("a",{attrs:{href:"#滥用点号的问题"}},[v._v("滥用点号的问题")])]),_("li",[_("a",{attrs:{href:"#忽略优先量词"}},[v._v("忽略优先量词")])]),_("li",[_("a",{attrs:{href:"#转义"}},[v._v("转义")])])])]),_("p"),v._v(" "),_("h2",{attrs:{id:"一般形式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一般形式"}},[v._v("#")]),v._v(" 一般形式")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("量词")]),v._v(" "),_("th",[v._v("说明")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("{n}")])]),v._v(" "),_("td",[v._v("之前的元素必须出现 n 次")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{m,n}")])]),v._v(" "),_("td",[v._v("之前的元素最少出现 m 次，最多出现 n 次")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{m,}")])]),v._v(" "),_("td",[v._v("之前的元素最少出现 m 次，出现次数无上限")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{0,n}")])]),v._v(" "),_("td",[v._v("之前的元素可以不出现，也可以出现，最多出现 n 次")])])])]),v._v(" "),_("h2",{attrs:{id:"常用量词"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用量词"}},[v._v("#")]),v._v(" 常用量词")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("常用量词")]),v._v(" "),_("th",[_("code",[v._v("{m,n}")]),v._v(" 等价形式")]),v._v(" "),_("th",[v._v("说明")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("*")])]),v._v(" "),_("td",[_("code",[v._v("{0,}")])]),v._v(" "),_("td",[v._v("可能出现，也可能不出现，出现次数没有上限")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("+")])]),v._v(" "),_("td",[_("code",[v._v("{1,}")])]),v._v(" "),_("td",[v._v("至少出现 1 次，出现次数没有上限")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("?")])]),v._v(" "),_("td",[_("code",[v._v("{0,1}")])]),v._v(" "),_("td",[v._v("至多出现 1 次，也可能不出现")])])])]),v._v(" "),_("p",[v._v("美国英语和英国英语有些词的写法是不一样的，比如 "),_("code",[v._v("traveler")]),v._v(" 和 "),_("code",[v._v("traveller")]),v._v("，如果希望“通吃” "),_("code",[v._v("traveler")]),v._v(" 和 "),_("code",[v._v("traveller")]),v._v("，就要求第 2 个 "),_("code",[v._v("l")]),v._v(" 是“至多出现 1 次，也可能不出现”的，正好使用 "),_("code",[v._v("?")]),v._v(" 量词："),_("code",[v._v("travell?er")]),v._v("。")]),v._v(" "),_("p",[v._v("其实这样的情况还有很多，比如 "),_("code",[v._v("favor")]),v._v(" 和 "),_("code",[v._v("favour")]),v._v("、"),_("code",[v._v("color")]),v._v(" 和 "),_("code",[v._v("colour")]),v._v("。此外还有很多其他应用场合，比如 "),_("code",[v._v("http")]),v._v(" 和 "),_("code",[v._v("https")]),v._v("，虽然是两个概念，但都是协议名，可以用 "),_("code",[v._v("https?")]),v._v(" 匹配；再比如表示价格的字符串，有可能是 "),_("code",[v._v("100")]),v._v(" 也有可能是 "),_("code",[v._v("￥100")]),v._v("，可以用 "),_("code",[v._v("￥?100")]),v._v(" 匹配。")]),v._v(" "),_("p",[v._v("量词也广泛应用于解析 HTML 代码。HTML 是一种“标签语言”，它包含各种各样的 tag（标签），比如 "),_("code",[v._v("<head>")]),v._v("、"),_("code",[v._v("<img>")]),v._v("、"),_("code",[v._v("<table>")]),v._v(" 等，这些 tag 的名字各异，形式却相同：从 "),_("code",[v._v("<")]),v._v(" 开始，到 "),_("code",[v._v(">")]),v._v(" 结束，在 "),_("code",[v._v("<")]),v._v(" 和 "),_("code",[v._v(">")]),v._v(" 之间有若干字符，“若干”的意思是长度不确定，但不能为 0（"),_("code",[v._v("<>")]),v._v(" 并不是合法的 tag），也不能是 "),_("code",[v._v(">")]),v._v(" 字符。如果要用一个正则表达式匹配所有的 tag，需要用 "),_("code",[v._v("<")]),v._v(" 匹配开头的 "),_("code",[v._v("<")]),v._v("，用 "),_("code",[v._v(">")]),v._v(" 匹配结尾的 "),_("code",[v._v(">")]),v._v("，用 "),_("code",[v._v("[^>]+")]),v._v(" 匹配中间的“若干字符”，字符至少出现 1 次，出现次数没有上限，所以整个正则表达式就是 "),_("code",[v._v("<[^>]+>")]),v._v("。")]),v._v(" "),_("p",[v._v("类似的，也可以使用正则表达式匹配 "),_("strong",[v._v("双引号字符串")]),v._v("。不同的是，双引号字符串的两个双引号之间可以没有任何字符，"),_("code",[v._v('""')]),v._v(" 是一个完全合法的字符串。应该使用量词 "),_("code",[v._v("*")]),v._v("，字符可能出现，也可能不出现，出现次数没有上限，于是整个正则表达式就成了 "),_("code",[v._v('"[^"]*"')]),v._v("。")]),v._v(" "),_("p",[v._v("注：字符串中表示双引号需要转义写成 "),_("code",[v._v('\\"')]),v._v("，这并不是正则表达式中的规定，而是为字符串转义考虑。")]),v._v(" "),_("p",[v._v("量词的使用有很多学问，不妨多看几个 tag 匹配的例子：tag 可以粗略分为 open tag 和 close tag，比如 "),_("code",[v._v("<head>")]),v._v(" 就是 open tag，而 "),_("code",[v._v("</html>")]),v._v(" 就是 close tag；另外还有一类标签是 self-closing tag，比如 "),_("code",[v._v("<br />")]),v._v(" 。现在来看分别匹配这三类 tag 的正则表达式。")]),v._v(" "),_("ol",[_("li",[_("p",[v._v("open tag 的特点是以 "),_("code",[v._v("<")]),v._v(" 开头，然后是“若干字符”（但不能以 "),_("code",[v._v("/")]),v._v(" 开头），最后是 "),_("code",[v._v(">")]),v._v("，所以对应的正则表达式是 "),_("code",[v._v("<[^/][^>]*>")]),v._v("；注意，因为 "),_("code",[v._v("[^/]")]),v._v(" 必须匹配一个字符，所以“若干字符”中其他部分必须写成 "),_("code",[v._v("[^>]*")]),v._v("，否则它无法匹配名字为单个字符的标签，比如 "),_("code",[v._v("<b>")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("close tag 的特点是以 "),_("code",[v._v("<")]),v._v(" 开头，之后是 "),_("code",[v._v("/")]),v._v(" 字符，然后是“若干字符（但不能以 "),_("code",[v._v("/")]),v._v(" 开头）”，最后是 "),_("code",[v._v(">")]),v._v("，所以对应的正则表达式是 "),_("code",[v._v("</[^>]+>")]),v._v("；")])]),v._v(" "),_("li",[_("p",[v._v("self-closing tag 的特点是以 "),_("code",[v._v("<")]),v._v(" 开头，中间是“若干字符”，最后是 "),_("code",[v._v("/>")]),v._v("，所以对应的正则表达式是 "),_("code",[v._v("<[^>]+/>")]),v._v("。注意：这里不是 "),_("code",[v._v("<[^>/]+/>")]),v._v("，排除型字符组只排除 "),_("code",[v._v(">")]),v._v("，而不排除 "),_("code",[v._v("/")]),v._v("，因为要确认的只是在结尾的 "),_("code",[v._v(">")]),v._v(" 之前出现 "),_("code",[v._v("/")]),v._v("，如果写成 "),_("code",[v._v("<[^>/]+/>")]),v._v("，则要求 tag 内部不能出现 "),_("code",[v._v("/")]),v._v("，就无法匹配 "),_("code",[v._v('<img src="http://somehost/picture" />')]),v._v(" 这类的 tag 了。")])])]),v._v(" "),_("p",[v._v("表 2-3 列出了匹配几类 tag 的表达式。")]),v._v(" "),_("p",[_("strong",[v._v("表 2-3 　各类 tag 的匹配")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("匹配所有 tag 的表达式")]),v._v(" "),_("th",[v._v("tag 分类")]),v._v(" "),_("th",[v._v("匹配分类 tag 的表达式")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("<[^>]+>")])]),v._v(" "),_("td",[v._v("open tag")]),v._v(" "),_("td",[_("code",[v._v("<[^/][^>]*>")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("<[^>]+>")])]),v._v(" "),_("td",[v._v("close tag")]),v._v(" "),_("td",[_("code",[v._v("</[^>]+>")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("<[^>]+>")])]),v._v(" "),_("td",[v._v("self-closing tag")]),v._v(" "),_("td",[_("code",[v._v("<[^>]+/>")])])])])]),v._v(" "),_("p",[v._v("对比表格中“匹配所有 tag 的表达式”和“匹配分类 tag 的表达式”，可以发现它们的模式是相近的，只是细节上有差异。也就是说，通过变换字符组和量词，可以准确控制正则表达式能匹配的字符串的范围，达到不同的目的。这其实是使用正则表达式时的一条根本规律："),_("strong",[v._v("使用合适的结构（包括字符组和量词），精确表达自己的意图，界定能匹配的文本。")])]),v._v(" "),_("p",[v._v("再仔细观察，你或许会发现，匹配 open tag 的表达式，也可以匹配 self-closing tag："),_("code",[v._v("<[^/][^>]*>")]),v._v(" 能够匹配 "),_("code",[v._v("<br />")]),v._v(" ，因为 "),_("code",[v._v("[^>]*")]),v._v(" 并不排除对 "),_("code",[v._v("/")]),v._v(" 的匹配。那么将表达式改为 "),_("code",[v._v("<[^/][^>]*[^/]>")]),v._v("，就保证匹配的 open tag 不会以 "),_("code",[v._v("/>")]),v._v(" 结尾了。")]),v._v(" "),_("p",[v._v("不过这会产生新的问题："),_("code",[v._v("<[^/][^>]*[^/]>")]),v._v(" 能匹配的 tag，在 "),_("code",[v._v("<")]),v._v(" 和 "),_("code",[v._v(">")]),v._v(" 之间出现了两个 "),_("code",[v._v("[^/]")]),v._v("，上一章已经讲过，排除型字符组表示“在当前位置，匹配一个没有列出的字符”，所以 tag 里的字符串必须至少包含两个字符，这样就无法匹配 "),_("code",[v._v("<u>")]),v._v(" 了。")]),v._v(" "),_("p",[v._v("仔细想想，真正要表达的意思是，在 tag 内部的字符串不能以 "),_("code",[v._v("/")]),v._v(" 开头，也不能以 "),_("code",[v._v("/")]),v._v(" 结尾，如果这个字符串只包含一个字符，那么它既是开头，又是结尾，使用两个排除型字符组显然是不合适的，看起来没办法解决了。其实，也只是现有的知识还不足够解决这个问题而已，后面我们将有两种解法：")]),v._v(" "),_("ul",[_("li",[v._v("运用第三章括号的 "),_("strong",[v._v("分组")]),v._v(" 功能")]),v._v(" "),_("li",[v._v("运用第四章断言的 "),_("strong",[v._v("环视")]),v._v(" 功能")])]),v._v(" "),_("h2",{attrs:{id:"点号"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#点号"}},[v._v("#")]),v._v(" 点号")]),v._v(" "),_("p",[v._v("第 1 章讲到了各种字符组，与它相关的还有一个特殊的元字符：点号 "),_("code",[v._v(".")]),v._v("。一般文档里都会提到，点号可以匹配“任意字符”，点号确实可以匹配“任意字符”，常见的数字、字母、各种符号都可以。")]),v._v(" "),_("p",[v._v("有一个字符不能由点号匹配，就是换行符 "),_("code",[v._v("\\n")]),v._v("。这个字符平时看不见，却存在，而且在处理时并不能忽略（第 3 章会给出具体的例子）。")]),v._v(" "),_("p",[v._v("如果非要匹配“任意字符”，有两种办法：")]),v._v(" "),_("ol",[_("li",[v._v("可以指定使用 "),_("strong",[v._v("单行")]),v._v(" 匹配模式 ，在这种模式下，点号可以匹配换行符")]),v._v(" "),_("li",[v._v("或者使用第 1 章介绍的“自制”通配字符组 "),_("code",[v._v("[\\s\\S]")]),v._v("（也可以使用 "),_("code",[v._v("[\\d\\D]")]),v._v(" 或 "),_("code",[v._v("[\\w\\W]")]),v._v("），正好涵盖了所有字符")])]),v._v(" "),_("h2",{attrs:{id:"滥用点号的问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#滥用点号的问题"}},[v._v("#")]),v._v(" 滥用点号的问题")]),v._v(" "),_("p",[v._v("因为点号能匹配几乎所有的字符，所以实际应用中许多人图省事，随意使用 "),_("code",[v._v(".*")]),v._v(" 或 "),_("code",[v._v(".+")]),v._v("，结果却事与愿违，下面以双引号字符串为例来说明。")]),v._v(" "),_("p",[v._v("之前我们使用表达式 "),_("code",[v._v('"[^"]*"')]),v._v(" 匹配双引号字符串，而“图省事”的做法是 "),_("code",[v._v('".*"')]),v._v("。通常这么用是没有问题的，但也可能有意外，例 2-12 就是一种“出乎意料”的情况。")]),v._v(" "),_("p",[v._v("用 "),_("code",[v._v('".*"')]),v._v(" 匹配双引号字符串，不但可以匹配正常的双引号字符串 "),_("code",[v._v('"quoted string"')]),v._v("，还可以匹配格式错误的字符串 "),_("code",[v._v('"quoted string1" and another "')]),v._v(" 和 "),_("code",[v._v('"quoted string1" and another "quoted string2"')]),v._v("。这是为什么呢？")]),v._v(" "),_("p",[v._v("在正则表达式 "),_("code",[v._v('".*"')]),v._v(" 中，点号 "),_("code",[v._v(".")]),v._v(" 可以匹配任何字符，"),_("code",[v._v("*")]),v._v(" 表示可以匹配的字符串长度没有限制，所以 "),_("code",[v._v(".*")]),v._v(" 在匹配过程结束以前，每遇到一个字符（除去无法匹配的 "),_("code",[v._v("\\n")]),v._v("），"),_("code",[v._v(".*")]),v._v(" 都可以匹配，但是"),_("u",[v._v("当遇到字符 "),_("code",[v._v('"')]),v._v(" 的时候")]),v._v("，到底是匹配这个字符，还是忽略它，将其交给之后的 "),_("code",[v._v('"')]),v._v(" 来匹配呢？")]),v._v(" "),_("p",[v._v("答案是，具体选择取决于所使用的量词。正则表达式中的量词分为几类，之前介绍的量词都可以归到一类，叫作 "),_("strong",[v._v("匹配优先量词")]),v._v("（greedy quantifier，也有人将其翻译为 "),_("strong",[v._v("贪婪量词")]),v._v("）。匹配优先量词，顾名思义，就是在拿不准是否要匹配的时候，优先尝试匹配，并且记下这个状态，以备将来“反悔”。")]),v._v(" "),_("p",[v._v("来看表达式 "),_("code",[v._v('".*"')]),v._v(' 对字符串"quoted string"的匹配过程。')]),v._v(" "),_("ol",[_("li",[v._v("一开始，"),_("code",[v._v('"')]),v._v(" 匹配 "),_("code",[v._v('"')]),v._v("，然后轮到字符 "),_("code",[v._v("q")]),v._v("，"),_("code",[v._v(".*")]),v._v(" 可以匹配它，也可以不匹配，因为使用了匹配优先量词，所以 "),_("code",[v._v(".*")]),v._v(" 先匹配 "),_("code",[v._v("q")]),v._v("，并且记录下这个状态【"),_("code",[v._v("q")]),v._v(" 也可能是 "),_("code",[v._v(".*")]),v._v(" 不应该匹配的】")]),v._v(" "),_("li",[v._v("接下来是字符 "),_("code",[v._v("u")]),v._v("，"),_("code",[v._v(".*")]),v._v(" 可以匹配它，也可以不匹配，因为使用了匹配优先量词，所以 "),_("code",[v._v(".*")]),v._v(" 先匹配 "),_("code",[v._v("u")]),v._v("，并且记录下这个状态【"),_("code",[v._v("u")]),v._v(" 也可能是 "),_("code",[v._v(".*")]),v._v(" 不应该匹配的】")]),v._v(" "),_("li",[v._v("……")]),v._v(" "),_("li",[v._v("现在轮到字符 "),_("code",[v._v("g")]),v._v("，"),_("code",[v._v(".*")]),v._v(" 可以匹配它，也可以不匹配，因为使用了匹配优先量词，所以 "),_("code",[v._v(".*")]),v._v(" 先匹配 "),_("code",[v._v("g")]),v._v("，并且记录下这个状态【"),_("code",[v._v("g")]),v._v(" 也可能是 "),_("code",[v._v(".*")]),v._v(" 不应该匹配的】")]),v._v(" "),_("li",[v._v("最后是末尾的 "),_("code",[v._v('"')]),v._v("，"),_("code",[v._v(".*")]),v._v(" 可以匹配它，也可以不匹配，因为使用了匹配优先量词，所以 "),_("code",[v._v(".*")]),v._v(" 先匹配 "),_("code",[v._v('"')]),v._v("，并且记录下这个状态【"),_("code",[v._v('"')]),v._v(" 也可能是 "),_("code",[v._v(".*")]),v._v(" 不应该匹配的】")]),v._v(" "),_("li",[v._v("这时候，字符串之后已经没有字符了，但正则表达式中还有 "),_("code",[v._v('"')]),v._v(" 没有匹配，所以只能查询之前保存备用的状态，看看能不能退回几步，照顾 "),_("code",[v._v('"')]),v._v(" 的匹配。查询到最近保存的状态是：【"),_("code",[v._v('"')]),v._v(" 也可能是 "),_("code",[v._v(".*")]),v._v(" 不应该匹配的】。于是让 "),_("code",[v._v(".*")]),v._v("“反悔”对 "),_("code",[v._v('"')]),v._v(" 的匹配，把 "),_("code",[v._v('"')]),v._v(" 交给 "),_("code",[v._v('"')]),v._v("，测试发现正好能匹配，所以整个匹配宣告成功。这个“反悔”的过程，专业术语叫作回溯（backtracking）")])]),v._v(" "),_("p",[v._v("如果我们把字符串换成 "),_("code",[v._v('"quoted string" and another "')]),v._v("，"),_("code",[v._v(".*")]),v._v(" 会首先匹配第一个双引号之后的所有字符，再进行回溯，表达式中的 "),_("code",[v._v('"')]),v._v(" 匹配了字符串结尾的字符 "),_("code",[v._v('"')]),v._v("，整个匹配宣告完成，过程如图 2-2 所示。")]),v._v(" "),_("p",[v._v("如果要准确匹配双引号字符串")]),v._v(" "),_("ul",[_("li",[v._v("不能使用 "),_("code",[v._v('".*"')]),v._v("，因为这将会匹配 "),_("code",[v._v("string")]),v._v(" 字符串中首个 "),_("code",[v._v('"')]),v._v(" 和末尾 "),_("code",[v._v('"')]),v._v(" 之前的所有内容")]),v._v(" "),_("li",[v._v("应该使用 "),_("code",[v._v('"[^"]*"')]),v._v("，因为这将会只匹配字符串中的第 1 个 "),_("code",[v._v('"')]),v._v(" 和第 2 个 "),_("code",[v._v('"')]),v._v(" 之间的内容")])]),v._v(" "),_("h2",{attrs:{id:"忽略优先量词"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#忽略优先量词"}},[v._v("#")]),v._v(" 忽略优先量词")]),v._v(" "),_("p",[v._v("也有些时候，确实需要用到 "),_("code",[v._v(".*")]),v._v("( 或者 "),_("code",[v._v("[\\s\\S]*")]),v._v("），比如匹配 HTML 代码中的 JavaScript 示例就是如此。")]),v._v(" "),_("p",[v._v("匹配的模式仍然是：匹配 open tag 和 close tag，以及它们之间的内容。open tag 是 "),_("code",[v._v('<script type="text/javascript">')]),v._v("，close tag 是 "),_("code",[v._v("<\/script>")]),v._v("，这两段的内容是固定的，非常容易写出对应的表达式，但之间的内容怎么匹配呢？在 JavaScript 代码中，各种字符都可能出现，所以不能用排除型字符组，只能用 "),_("code",[v._v(".*")]),v._v("。比如，用一个正则表达式匹配下面这段 HTML 源代码：")]),v._v(" "),_("p",[v._v("开头和结尾的 tag 都容易匹配，中间的代码比较麻烦，因为点号 "),_("code",[v._v(".")]),v._v(" 不能匹配换行符，所以必须使用 "),_("code",[v._v("[\\s\\S]")]),v._v("（或者 "),_("code",[v._v("[\\d\\D]")]),v._v("、"),_("code",[v._v("[\\w\\W]")]),v._v("）。")]),v._v(" "),_("p",[v._v("这个表达式确实可以匹配上面的 JavaScript 代码。但是如果遇到更复杂的情况就会出错，比如针对下面这段 HTML 代码，程序运行结果如例 2-13。")]),v._v(" "),_("p",[v._v("用 "),_("code",[v._v('<script type="text/javascript">[\\s\\S]*<\/script>')]),v._v(" 来匹配，会一次性匹配两段 JavaScript 代码，甚至包含之间不是 JavaScript 的代码。")]),v._v(" "),_("p",[v._v("按照匹配原理，"),_("code",[v._v("[\\s\\S]*")]),v._v(" 先匹配所有的文本，回溯时交还最后的 "),_("code",[v._v("<\/script>")]),v._v("，整个表达式的匹配就成功了，逻辑就是如此，无可改进。而且，这个问题也不能模仿之前双引号字符串匹配，用 "),_("code",[v._v('[^"]*')]),v._v(" 匹配 "),_("code",[v._v("<script…>")]),v._v(" 和 "),_("code",[v._v("<\/script>")]),v._v(" 之间的代码，因为排除型字符组只能排除单个字符，"),_("code",[v._v("[^<\/script>]")]),v._v(" 不能表示“不是 "),_("code",[v._v("<\/script>")]),v._v(" 的字符串”。")]),v._v(" "),_("p",[v._v("换个角度，通过改变 "),_("code",[v._v("[\\s\\S]*")]),v._v(" 的匹配策略来解决问题：在不确定是否要匹配的场合，先尝试不匹配的选择，测试正则表达式中后面的元素，如果失败，再退回来尝试 "),_("code",[v._v(".*")]),v._v(" 匹配，如此就没有问题了。")]),v._v(" "),_("p",[v._v("循着这个思路，正则表达式中还提供了 "),_("strong",[v._v("忽略优先量词")]),v._v("（lazy quantifier 或 reluctant quantifier，也有人将其翻译为 "),_("strong",[v._v("懒惰量词")]),v._v("），如果不确定是否要匹配，忽略优先量词会选择“不匹配”的状态，再尝试表达式中之后的元素，如果尝试失败，再回溯，选择之前保存的“匹配”的状态。")]),v._v(" "),_("p",[v._v("对 "),_("code",[v._v("[\\s\\S]*")]),v._v(" 来说，把 "),_("code",[v._v("*")]),v._v(" 改为 "),_("code",[v._v("*?")]),v._v(" 就是使用了忽略优先量词，"),_("code",[v._v("*?")]),v._v(" 限定的元素出现次数范围与 "),_("code",[v._v("*")]),v._v(" 完全一样，都表示“可能出现，也可能不出现，出现次数没有上限”。区别在于，在实际匹配过程中，遇到 "),_("code",[v._v("[\\s\\S]")]),v._v(" 能匹配的字符，先尝试“忽略”，如果后面的元素（具体到这个表达式中，是 "),_("code",[v._v("<\/script>")]),v._v("）不能匹配，再尝试“匹配”，这样就保证了结果的正确性，代码见例 2-14。")]),v._v(" "),_("p",[v._v("从表 2-4 可以看到，匹配优先量词与忽略优先量词逐一对应，只是在对应的匹配优先量词之后添加 "),_("code",[v._v("?")]),v._v("，两者限定的元素能出现的次数也一样，遇到不能匹配的情况同样需要回溯；唯一的区别在于，忽略优先量词会优先选择“忽略”，而匹配优先量词会优先选择“匹配”。")]),v._v(" "),_("p",[_("strong",[v._v("表 2-4 　匹配优先量词与忽略优先量词")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("匹配优先量词")]),v._v(" "),_("th",[v._v("忽略优先量词")]),v._v(" "),_("th",[v._v("限定次数")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("*")])]),v._v(" "),_("td",[_("code",[v._v("*?")])]),v._v(" "),_("td",[v._v("可能不出现，也可能出现，出现次数没有上限")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("+")])]),v._v(" "),_("td",[_("code",[v._v("+?")])]),v._v(" "),_("td",[v._v("至少出现 1 次，出现次数没有上限")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("?")])]),v._v(" "),_("td",[_("code",[v._v("??")])]),v._v(" "),_("td",[v._v("至多出现 1 次，也可以不出现")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{m,n}")])]),v._v(" "),_("td",[_("code",[v._v("{m,n}?")])]),v._v(" "),_("td",[v._v("出现次数最少为 m 次，最多为 n 次")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{m,}")])]),v._v(" "),_("td",[_("code",[v._v("{m,}?")])]),v._v(" "),_("td",[v._v("出现次数最少为 m 次，没有上限")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{,n}")])]),v._v(" "),_("td",[_("code",[v._v("{,n}?")])]),v._v(" "),_("td",[v._v("可能不出现，也可能出现，最多出现 n 次")])])])]),v._v(" "),_("p",[_("strong",[v._v("忽略优先量词")]),v._v(" 还可以完成许多其他功能，典型的例子就是提取代码中的 C 语言注释。")]),v._v(" "),_("p",[v._v("C 语言的注释有两种：一种是在行末，以 "),_("code",[v._v("//")]),v._v(" 开头；另一种可以跨多行，以 "),_("code",[v._v("/*")]),v._v(" 开头，以 "),_("code",[v._v("*/")]),v._v(" 结束。第一种注释很好匹配，使用 "),_("code",[v._v("//.*")]),v._v(" 即可，因为点号 "),_("code",[v._v(".")]),v._v(" 不能匹配换行符，所以 "),_("code",[v._v("//.*")]),v._v(" 匹配的就是从 "),_("code",[v._v("//")]),v._v(" 直到行末的文本，注意这里使用了量词 "),_("code",[v._v("*")]),v._v("，因为 "),_("code",[v._v("//")]),v._v(" 可能就是该行最后两个字符；第二种注释稍微复杂一点，因为 "),_("code",[v._v("/*…*/")]),v._v(" 的注释和 JavaScript 一样，可能分成许多段，所以必须用到忽略优先量词；同时因为注释可能横跨多行，所以必须使用 "),_("code",[v._v("[\\s\\S]")]),v._v("。因此，整个表达式就是 "),_("code",[v._v("/\\*[\\s\\S]*?\\*/")]),v._v("（别忘了 "),_("code",[v._v("*")]),v._v(" 的转义）。")]),v._v(" "),_("p",[v._v("另一个比较典型的例子是提取出 HTML 代码中的超链接。常见的超链接形似 "),_("code",[v._v('<a href=" ">text</a>')]),v._v("。它以 "),_("code",[v._v("<a")]),v._v(" 开头，以 "),_("code",[v._v("</a>")]),v._v(" 结束，"),_("code",[v._v("href")]),v._v(" 属性是超链接的地址。我们无法预先判断 "),_("code",[v._v("<a>")]),v._v(" 和 "),_("code",[v._v("</a>")]),v._v(" 之间到底会出现哪些字符，不会出现哪些字符，只知道其中的内容一直到 "),_("code",[v._v("</a>")]),v._v(" 结束，程序代码见例 2-15。")]),v._v(" "),_("p",[v._v("值得注意的是，这个表达式中的 "),_("code",[v._v("<a")]),v._v(" 之后并没有使用普通空格，而是使用字符组简记法 "),_("code",[v._v("\\s")]),v._v("。HTML 语法并没有规定此处的空白只能使用空格字符，也没有规定必须使用一个空白字符，所以我们用 "),_("code",[v._v("\\s")]),v._v(" 保证“至少出现一个空白字符”（但是不能没有这个空白字符，否则就不能保证匹配 tag 的 "),_("code",[v._v("name")]),v._v(" 是 "),_("code",[v._v("a")]),v._v("）。")]),v._v(" "),_("p",[v._v("之前用来匹配 JavaScript 的表达式是 "),_("code",[v._v('<script language="text/javascript">[\\s\\S]*?<\/script>')]),v._v("，它能应对的情况实在太少了：在 "),_("code",[v._v("<script")]),v._v(" 之后可能不是空格，而是空白字符；再之后可能是 "),_("code",[v._v('type="text/javascript"')]),v._v("，也可能是 "),_("code",[v._v('type="application/javascript"')]),v._v("，也可能用 "),_("code",[v._v("language")]),v._v(" 取代 "),_("code",[v._v("type")]),v._v("（实际上 "),_("code",[v._v("language")]),v._v(" 是以前的写法，现在大都用 "),_("code",[v._v("type")]),v._v("），甚至可能没有属性，直接是 "),_("code",[v._v("<script>")]),v._v("。[6]")]),v._v(" "),_("p",[v._v("所以必须改造这个表达式，将条件放宽：在 "),_("code",[v._v("script")]),v._v(" 之后，可能出现空白字符，也可能直接是 "),_("code",[v._v(">")]),v._v("，这部分可以用一个字符组 "),_("code",[v._v("[\\s>]")]),v._v(" 来匹配，之后的内容统一用 "),_("code",[v._v("[\\s\\S]+?")]),v._v(" 匹配，忽略优先量词保证了匹配进行到最近的 "),_("code",[v._v("<\/script>")]),v._v(" 为止。最终得到的表达式就是 "),_("code",[v._v("<script[\\s>][\\s\\S]+?<\/script>")]),v._v("。")]),v._v(" "),_("p",[v._v("对这个表达式稍加改造，就可以写出匹配类似 tag 的表达式。在解析页面时，常见的需求是提取表格中各行、各单元（cell）的内容。表格的 tag 是 "),_("code",[v._v("<table>")]),v._v("，行的 tag 是 "),_("code",[v._v("<tr>")]),v._v("，单元的 tag 是 "),_("code",[v._v("<td>")]),v._v("，所以，它们可以分别用下面的表达式匹配，请注意其中的 "),_("code",[v._v("[\\s>]")]),v._v("，它兼顾了可能存在的其他属性（比如 "),_("code",[v._v('<table border="1">')]),v._v("），同时排除了可能的错误（比如 "),_("code",[v._v("<tablet>")]),v._v("）。")]),v._v(" "),_("p",[v._v("在实际的 HTML 代码中，"),_("code",[v._v("table")]),v._v("、"),_("code",[v._v("tr")]),v._v("、"),_("code",[v._v("td")]),v._v(" 这三个元素经常是嵌套的，它们之间存在着包含关系。但是，仅仅使用正则表达式匹配，并不能得到“某个 "),_("code",[v._v("table")]),v._v(" 包含哪些 "),_("code",[v._v("tr")]),v._v("”“某个 "),_("code",[v._v("td")]),v._v(" 属于哪个 "),_("code",[v._v("tr")]),v._v("”这种信息。此时需要像例 2-16 那样，用程序整理出来。")]),v._v(" "),_("p",[_("strong",[v._v("注：因为 tag 是不区分大小写的，所以如果还希望匹配大写的情况，则必须使用字符组，"),_("code",[v._v("table")]),v._v(" 写成 "),_("code",[v._v("[tT][aA][bB][lL][eE]")]),v._v("，"),_("code",[v._v("tr")]),v._v(" 写成 "),_("code",[v._v("[tT][rR]")]),v._v("，"),_("code",[v._v("td")]),v._v(" 写成 "),_("code",[v._v("[tT][dD]")]),v._v("。")])]),v._v(" "),_("p",[v._v("这个例子说明，正则表达式只能进行纯粹的文本处理，单纯依靠它不能整理出层次结构；如果希望解析文本的同时构建层次结构信息，则必须将正则表达式配合程序代码一起使用。")]),v._v(" "),_("p",[v._v("回过头想想双引号字符串的匹配，之前使用的正则表达式是 "),_("code",[v._v('"[^"]*"')]),v._v("，其实也可以使用忽略优先量词解决 "),_("code",[v._v('".*?"')]),v._v("（如果双引号字符串中包含换行符，则使用 "),_("code",[v._v('"[\\s\\S]*?"')]),v._v(") 。两种办法相比，哪个更好呢？")]),v._v(" "),_("p",[v._v("一般来说，"),_("code",[v._v('"[^"]*"')]),v._v(" 更好。首先，"),_("code",[v._v('[^"]')]),v._v(" 本身能够匹配换行符，涵盖了点号 "),_("code",[v._v(".")]),v._v(" 可能无法应付的情况，出于习惯，很多人更愿意使用点号 "),_("code",[v._v(".")]),v._v(" 而不是 "),_("code",[v._v("[\\s\\S]")]),v._v("；其次，匹配优先量词只需要考虑自己限定的元素能否匹配即可，而忽略优先量词必须兼顾它所限定的元素与之后的元素，效率自然大大降低，如果字符串很长，两者的速度可能有明显的差异。")]),v._v(" "),_("p",[v._v("而且，有些情况下确实必须用到匹配优先量词，比如文件名的解析就如此。UNIX/Linux 下的文件名类似 "),_("code",[v._v("/usr/local/bin/python")]),v._v(" 这样，它包含两个部分：路径是 "),_("code",[v._v("/usr/local/bin/")]),v._v("；真正的文件名是 "),_("code",[v._v("python")]),v._v("。为了在 "),_("code",[v._v("/usr/local/bin/python")]),v._v(" 中解析出两个部分，使用匹配优先量词是非常方便的。从字符串的起始位置开始，用 "),_("code",[v._v(".*/")]),v._v(" 匹配路径，根据之前介绍的知识，它会回溯到最后（最右）的斜线字符 "),_("code",[v._v("/")]),v._v("，也就是文件名之前；在字符串的结尾部分，"),_("code",[v._v("[^/]*")]),v._v(" 能匹配的就是真正的文件名。第 1 章介绍过 "),_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v("，它们分别表示“定位到字符串的开头”和“定位到字符串的结尾”，所以应该把 "),_("code",[v._v("^")]),v._v(" 加在匹配路径的表达式之前，得到 "),_("code",[v._v("^.*/")]),v._v("，而把 "),_("code",[v._v("$")]),v._v(" 加在匹配真正文件名的表达式之后，得到 "),_("code",[v._v("[^/]*$")]),v._v("，代码见例 2-17。")]),v._v(" "),_("p",[v._v("Windows 下的路径分隔符是 "),_("code",[v._v("\\")]),v._v("，比如 "),_("code",[v._v("C: \\Program Files\\Python 2.7.1\\python.exe")]),v._v("，所以在正则表达式中，应该把斜线字符 "),_("code",[v._v("/")]),v._v(" 换成反斜线字符 "),_("code",[v._v("\\")]),v._v("。因为在正则表达式中反斜线字符 "),_("code",[v._v("\\")]),v._v(" 是用来转义其他字符的，为了表示反斜线字符本身，必须连写两个反斜线，所以两个表达式分别改为 "),_("code",[v._v("^.*\\\\")]),v._v(" 和 "),_("code",[v._v("[^\\\\]*$")]),v._v("。")]),v._v(" "),_("h2",{attrs:{id:"转义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转义"}},[v._v("#")]),v._v(" 转义")]),v._v(" "),_("p",[v._v("在正则表达式中，"),_("code",[v._v("*")]),v._v("、"),_("code",[v._v("+")]),v._v("、"),_("code",[v._v("?")]),v._v(" 等作为量词的字符具有特殊意义，但有些情况下我们需要的就是这些字符本身，此时就必须使用转义，也就是在它们之前添加反斜线 "),_("code",[v._v("\\")]),v._v("。")]),v._v(" "),_("p",[v._v("对常用量词所使用的字符 "),_("code",[v._v("+")]),v._v("、"),_("code",[v._v("*")]),v._v("、"),_("code",[v._v("?")]),v._v(" 来说，如果希望表示这三个字符本身，直接添加反斜线，变为 "),_("code",[v._v("\\+")]),v._v("、"),_("code",[v._v("\\*")]),v._v("、"),_("code",[v._v("\\?")]),v._v(" 即可。但是在一般形式的量词 "),_("code",[v._v("{m,n}")]),v._v(" 字符串中，虽然具有特殊含义的字符不止一个，转义时却只需要给第一个 "),_("code",[v._v("{")]),v._v(" 添加反斜线即可。也就是说，如果希望匹配字符串 "),_("code",[v._v("{m,n}")]),v._v("，正则表达式必须写成 "),_("code",[v._v("\\{m,n}")]),v._v("。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("量词字符/字符串")]),v._v(" "),_("th",[v._v("转义形式")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[_("code",[v._v("{n}")])]),v._v(" "),_("td",[_("code",[v._v("\\{n}")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{m,n}")])]),v._v(" "),_("td",[_("code",[v._v("\\{m,n}")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{m,}")])]),v._v(" "),_("td",[_("code",[v._v("\\{m,}")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("{0,n}")])]),v._v(" "),_("td",[_("code",[v._v("\\{0,n}")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("*")])]),v._v(" "),_("td",[_("code",[v._v("\\*")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("+")])]),v._v(" "),_("td",[_("code",[v._v("\\+")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("?")])]),v._v(" "),_("td",[_("code",[v._v("\\?")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("*?")])]),v._v(" "),_("td",[_("code",[v._v("\\*\\?")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("+?")])]),v._v(" "),_("td",[_("code",[v._v("\\+\\?")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("??")])]),v._v(" "),_("td",[_("code",[v._v("\\?\\?")])])])])]),v._v(" "),_("p",[v._v("之前还介绍了点号 "),_("code",[v._v(".")]),v._v("，所以别忘了点号的转义：点号 "),_("code",[v._v(".")]),v._v(" 是一个元字符，它可以匹配除换行符之外的任何字符，所以如果只想匹配点号本身，必须将它转义为 "),_("code",[v._v("\\.")]),v._v("。")]),v._v(" "),_("p",[v._v("在 VS Code 里面，正则表达式应该是 ECMAJavaScript (JavaScript) 风格，表达式里的字符 "),_("code",[v._v("/")]),v._v(" 必须转义。例如，为了匹配类似于 "),_("code",[v._v("</code>")]),v._v(" 这样的 Closing Tag，正则表达式应该写成 "),_("code",[v._v("<\\/code>")]),v._v("，也就是说 "),_("code",[v._v("/")]),v._v(" 必须转义，写成 "),_("code",[v._v("\\/")]),v._v(" 才可以。在 Python 里面，字符 "),_("code",[v._v("/")]),v._v(" 则不需转义。")])])}),[],!1,null,null,null);_.default=o.exports}}]);