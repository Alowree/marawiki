(window.webpackJsonp=window.webpackJsonp||[]).push([[402],{745:function(v,_,e){"use strict";e.r(_);var t=e(4),o=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("正则表达式中的大多数结构匹配的文本会出现在最终的匹配结果中（一般用 "),_("code",[v._v("group(0)")]),v._v(" 可以得到），但是也有些结构并不真正匹配文本，而只负责判断在某个位置左/右侧的文本是否符合要求，这种结构被称为 "),_("strong",[v._v("断言")]),v._v("（assertion）。常见的断言有三类：")]),v._v(" "),_("ul",[_("li",[v._v("单词边界")]),v._v(" "),_("li",[v._v("行起始/结束位置")]),v._v(" "),_("li",[v._v("环视")])]),v._v(" "),_("p",[v._v("以下是正文内容。")]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#单词边界"}},[v._v("单词边界")])]),_("li",[_("a",{attrs:{href:"#行-起始-结束-位置"}},[v._v("行 起始/结束 位置")])]),_("li",[_("a",{attrs:{href:"#前后查找"}},[v._v("前后查找")])])])]),_("p"),v._v(" "),_("h2",{attrs:{id:"单词边界"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#单词边界"}},[v._v("#")]),v._v(" 单词边界")]),v._v(" "),_("p",[v._v("在文本处理中经常可能进行单词替换，比如把一段文本中的 "),_("code",[v._v("row")]),v._v(" 都替换成 "),_("code",[v._v("line")]),v._v("。一般想到的是调用字符串的替换方法，直接替换 "),_("code",[v._v("row")]),v._v("。在不同语言中这些方法各不相同，但差别不大。")]),v._v(" "),_("p",[v._v("不过，这样替换也可能会造成意想不到的后果。")]),v._v(" "),_("p",[v._v("不仅所有单词 "),_("code",[v._v("row")]),v._v(" 都被替换成了 "),_("code",[v._v("line")]),v._v(", tomorrow 和 rowdy 两个单词内部的 "),_("code",[v._v("row")]),v._v(" 也被替换成了 "),_("code",[v._v("line")]),v._v("，这显然不是我们想要的结果。")]),v._v(" "),_("p",[v._v("要解决这个问题，必须有办法确定 "),_("strong",[v._v("单词")]),v._v(" "),_("code",[v._v("row")]),v._v("，而不是 "),_("strong",[v._v("字符串")]),v._v(" "),_("code",[v._v("row")]),v._v("。为解决这类问题，正则表达式提供了专用的 "),_("strong",[v._v("单词边界")]),v._v("（word boundary），记为 "),_("code",[v._v("\\b")]),v._v("。它匹配的是“单词边界”位置，而不是字符。也就是说，"),_("code",[v._v("\\b")]),v._v(" 能够匹配这样的位置：一边是单词字符，另一边不是单词字符。")]),v._v(" "),_("p",[_("strong",[v._v("表 4-1 　单词边界的匹配")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("字符串")]),v._v(" "),_("th",[_("code",[v._v("\\brow\\b")])]),v._v(" "),_("th",[_("code",[v._v("\\brow")])]),v._v(" "),_("th",[_("code",[v._v("row\\b")])])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("tomorrow")]),v._v(" "),_("td"),v._v(" "),_("td"),v._v(" "),_("td",[v._v("Y")])]),v._v(" "),_("tr",[_("td",[v._v("brown")]),v._v(" "),_("td"),v._v(" "),_("td"),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("row")]),v._v(" "),_("td",[v._v("Y")]),v._v(" "),_("td",[v._v("Y")]),v._v(" "),_("td",[v._v("Y")])]),v._v(" "),_("tr",[_("td",[v._v("rowdy")]),v._v(" "),_("td"),v._v(" "),_("td",[v._v("Y")]),v._v(" "),_("td")]),v._v(" "),_("tr",[_("td",[v._v("表达式说明")]),v._v(" "),_("td",[v._v("只能是单词 row")]),v._v(" "),_("td",[v._v("右边是 row，左边必须是非单词字符")]),v._v(" "),_("td",[v._v("左边是 row，右边必须是非单词字符")])])])]),v._v(" "),_("p",[v._v("观察表格，可以发现两点：第一，单词边界 "),_("strong",[v._v("并不区分左右")]),v._v("，在“单词边界”上，可能只有左侧是单词字符，也可能只有右侧是单词字符，总的来说，单词字符只能出现在一侧；第二，单词字符要求“"),_("strong",[v._v("另一边不是单词字符")]),v._v("”，而不是“"),_("strong",[v._v("另一边的字符不是单词字符")]),v._v("”，也就是说，"),_("strong",[v._v("一边必须出现单词字符，另一边可以出现非单词字符，也可能没有任何字符")]),v._v("。所以，如果字符串只包含单词 "),_("code",[v._v("word")]),v._v("，用 "),_("code",[v._v("\\bword\\b")]),v._v(" 应该是可以匹配的，虽然 "),_("code",[v._v("w")]),v._v(" 之前和 "),_("code",[v._v("d")]),v._v(" 之后都没有任何字符。")]),v._v(" "),_("p",[v._v("单词边界要求一侧必须出现单词字符，到底什么是单词字符呢？")]),v._v(" "),_("p",[v._v("一般情况下，“单词字符”的解释是 "),_("code",[v._v("\\w")]),v._v(" 能匹配的字符。在 JavaScript、PHP、Python、Ruby 中，"),_("code",[v._v("\\w")]),v._v(" 只能匹配 "),_("code",[v._v("[0-9a-zA-Z_]")]),v._v("。所以在这些语言中，"),_("code",[v._v("\\b\\w+\\b")]),v._v(" 能准确匹配英文单词了。给定一段文本，就可以用 "),_("code",[v._v("\\b\\w+\\b")]),v._v(" 将所有的单词提取出来。")]),v._v(" "),_("p",[v._v("但是也有些单词，"),_("code",[v._v("\\b\\w+\\b")]),v._v(" 是无能为力的，比如 "),_("code",[v._v("e-mail")]),v._v(" 和 "),_("code",[v._v("M.I.T.")]),v._v("。因为连字符 "),_("code",[v._v("-")]),v._v(" 和点号 "),_("code",[v._v(".")]),v._v(" 都不能由 "),_("code",[v._v("\\w")]),v._v(" 匹配，所以 "),_("code",[v._v("\\b\\w+\\b")]),v._v(" 无法匹配 "),_("code",[v._v("e-mail")]),v._v("，也无法匹配 "),_("code",[v._v("M.I.T.")]),v._v("。如果确实希望处理 "),_("code",[v._v("e-mail")]),v._v(" 之类的“单词”，也可以把表达式改为 "),_("code",[v._v("\\b[-\\w]+\\b")]),v._v("。")]),v._v(" "),_("p",[v._v("如果使用的是 .NET 或者 Python 3，在默认情况下，"),_("code",[v._v("\\w")]),v._v(" 不仅仅等价于 "),_("code",[v._v("[0-9a-zA-Z_]")]),v._v("，还能匹配各种语言中的“单词字符”，包括中文字符，这时 "),_("code",[v._v("\\b")]),v._v(" 的使用就有很大不同，具体情况现在不展开。")]),v._v(" "),_("p",[v._v("与单词边界 "),_("code",[v._v("\\b")]),v._v(" 对应的还有非单词边界 "),_("code",[v._v("\\B")]),v._v("，两者的关系类似 "),_("code",[v._v("\\s")]),v._v(" 和 "),_("code",[v._v("\\S")]),v._v("、"),_("code",[v._v("\\w")]),v._v(" 和 "),_("code",[v._v("\\W")]),v._v("、"),_("code",[v._v("\\d")]),v._v(" 和 "),_("code",[v._v("\\D")]),v._v("：在同一种语言中，不管 "),_("code",[v._v("\\b")]),v._v(" 是如何规定的，"),_("code",[v._v("\\b")]),v._v(" 能匹配的位置，"),_("code",[v._v("\\B")]),v._v(" 就不能匹配；"),_("code",[v._v("\\B")]),v._v(" 能匹配的位置，"),_("code",[v._v("\\b")]),v._v(" 就不能匹配。但是在实际使用中，"),_("code",[v._v("\\B")]),v._v(" 使用频率远远少于 "),_("code",[v._v("\\b")]),v._v("，所以暂不做详细介绍。")]),v._v(" "),_("h2",{attrs:{id:"行-起始-结束-位置"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#行-起始-结束-位置"}},[v._v("#")]),v._v(" 行 起始/结束 位置")]),v._v(" "),_("p",[v._v("单词边界匹配的是某个位置而不是文本，在正则表达式中，这类匹配位置的元素叫作 "),_("strong",[v._v("锚点")]),v._v("（anchor），它用来“定位”到某个位置。除了刚才介绍的 "),_("code",[v._v("\\b")]),v._v("，常用的锚点还有 "),_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v("。通常来说，它们分别匹配字符串的开始位置和结束位置，所以可以用来判断“整个字符串能否由表达式匹配”。这两个锚点在第 1 章粗略介绍过，现在仔细讲解。")]),v._v(" "),_("p",[v._v("一般情况下，"),_("code",[v._v("^")]),v._v(" 匹配 "),_("strong",[v._v("整个字符串的起始位置")]),v._v("。")]),v._v(" "),_("p",[v._v("依靠 "),_("code",[v._v("^")]),v._v("，就可以用正则表达式 "),_("code",[v._v("^Some")]),v._v(" 准确验证字符串“是否以 Some 开头”，因为 "),_("code",[v._v("^")]),v._v(" 会把整个表达式的匹配“定位”在字符串的开始位置。这样，即便表达式的其他部分可以在字符串中其他位置找到匹配，整个表达式也无法匹配成功。")]),v._v(" "),_("p",[v._v("在某些情况下，"),_("code",[v._v("^")]),v._v(" 也可以匹配字符串内部的“行起始位置”。在讲解这种情况之前，我们先来看看行是怎么划分的。")]),v._v(" "),_("p",[v._v("在编辑文本时，敲回车键就输入 "),_("strong",[v._v("行终止符")]),v._v("（Line terminal），结束当前行，新起一行。看起来，这很好理解，然而不同平台上的行终止符其实各不相同，表 4-2 列出了常见平台下的“行终止符”（这里不说“回车”而说“行终止符”是为了避免混淆，因为 "),_("code",[v._v("\\r")]),v._v(" 字符就叫“回车（符）”，而 "),_("code",[v._v("\\n")]),v._v(" 字符叫作“换行符”，“这里的回车是由回车符和换行符构成的”之类说法容易引起误解）。")]),v._v(" "),_("p",[_("strong",[v._v("表 4-2 　不同平台下的行终止符")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("平台")]),v._v(" "),_("th",[v._v("行终止符")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("UNIX/Linux")]),v._v(" "),_("td",[_("code",[v._v("\\n")])])]),v._v(" "),_("tr",[_("td",[v._v("Windows")]),v._v(" "),_("td",[_("code",[v._v("\\r\\n")])])]),v._v(" "),_("tr",[_("td",[v._v("Mac OS")]),v._v(" "),_("td",[_("code",[v._v("\\n")])])])])]),v._v(" "),_("p",[v._v("有些资料上说 Mac OS 中的换行符是 "),_("code",[v._v("\\r")]),v._v("，这并不算错，但只有 OS 9 之前的版本中，换行符才是 "),_("code",[v._v("\\r")]),v._v("。从 OS X 开始，换行符与 UNIX/Linux 一样都是 "),_("code",[v._v("\\n")]),v._v("，考虑到 OS 9 距今已经很久了，本书不考虑 "),_("code",[v._v("\\r")]),v._v(" 的情况。可参考 http://en.wikipedia.org/wiki/Newline。")]),v._v(" "),_("p",[v._v("也就是说，每一行的“起始位置”，就是“行终止符”之后的那个位置，如果没有专门的符号，就要考虑各种“行终止符”。下面的例子看得更清楚，为了让换行符“可见”，我们用 "),_("kbd",[v._v("NL")]),v._v(" 表示。")]),v._v(" "),_("div",{staticClass:"language-markdown line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-markdown"}},[_("code",[v._v("first line\nsecond line\nlast line\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br")])]),_("p",[v._v("它其实是下面这样，其中的 "),_("kbd",[v._v("NL")]),v._v(" 可能是 "),_("code",[v._v("\\n")]),v._v("，也可能是 "),_("code",[v._v("\\r\\n")]),v._v("。")]),v._v(" "),_("p",[v._v("first line"),_("kbd",[v._v("NL")]),v._v("second line"),_("kbd",[v._v("NL")]),v._v("last line")]),v._v(" "),_("p",[v._v("如果把匹配模式设定为 "),_("strong",[v._v("多行模式")]),v._v("（Multiline Mode，这是一种影响元字符匹配的设定，下一章详细讲解）下，"),_("code",[v._v("^")]),v._v(" 就既可以匹配整个字符串的起始位置，也可以匹配换行符之后的位置（设定多行模式最简单的办法是在正则表达式之前加上 "),_("code",[v._v("(?m)")]),v._v("，这里虽然出现了括号，但因为是专用于指定匹配模式，所以 "),_("strong",[v._v("不会")]),v._v(" 作为捕获分组）。")]),v._v(" "),_("p",[v._v("注意，如果字符串的末尾出现了行终止符，"),_("code",[v._v("^")]),v._v(" 也会匹配这个行终止符之后的位置。这样做是有意义的，比如要在每行开头加上特殊标注（最常见的处理是把纯文本格式转换为 HTML 格式），末尾的空行自然不应该漏掉。不过一般来说，"),_("code",[v._v("^")]),v._v(" 的主要用途是与其他子表达式配合，提取每行的第一个单词。")]),v._v(" "),_("p",[v._v("有些时候，我们无论如何也不想定位到字符串内部的行起始位置，只关心整个字符串的起始位置，则可以使用 "),_("code",[v._v("\\A")]),v._v("，绝大多数工具中的正则表达式都支持这个锚点，它在任何情况下（包括多行模式下）都只匹配整个字符串的起始位置。")]),v._v(" "),_("p",[v._v("“行结束位置”的情况更复杂。除去“行终止符”可能由各种字符表示的情况之外，“行结束位置”可能没有任何字符，还是上面的字符串，你猜猜它有几个行终止符？")]),v._v(" "),_("p",[v._v("字符串：Some sample text")]),v._v(" "),_("p",[v._v("可能一：Some sample text")]),v._v(" "),_("p",[v._v("可能二：Some sample text"),_("kbd",[v._v("NL")]),v._v("，而且其中的 "),_("kbd",[v._v("NL")]),v._v(" 可能是 "),_("code",[v._v("\\n")]),v._v("，也可能是 "),_("code",[v._v("\\r\\n")]),v._v("。")]),v._v(" "),_("p",[v._v("如果要匹配字符串的最后一个单词，不但必须考虑 "),_("kbd",[v._v("NL")]),v._v(" 所对应字符的多种可能，而且要兼顾 "),_("kbd",[v._v("NL")]),v._v(" 是否出现，情况更加复杂。")]),v._v(" "),_("p",[v._v("针对这种问题，正则表达式提供了“通吃”行结束符的锚点 "),_("code",[v._v("$")]),v._v("，它匹配的同样是位置。通常它匹配的是整个字符串的结尾位置—如果最后是行终止符，则匹配行终止符之前的位置；否则，匹配最后一个字符之后的位置。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("字符串"),_("div",{staticStyle:{width:"100px"}})]),v._v(" "),_("th",[v._v("Some sample text")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("字符串 1")]),v._v(" "),_("td",[v._v("Some sample text")])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("$")]),v._v(" 能匹配的位置")]),v._v(" "),_("td",[_("del",[v._v("Some sample text")]),_("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[_("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.437ex"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"1.131ex",height:"2.007ex",role:"img",focusable:"false",viewBox:"0 -694 500 887","aria-hidden":"true"}},[_("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[_("g",{attrs:{"data-mml-node":"math"}},[_("g",{attrs:{"data-mml-node":"mo"}},[_("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"2191",d:"M27 414Q17 414 17 433Q17 437 17 439T17 444T19 447T20 450T22 452T26 453T30 454T36 456Q80 467 120 494T180 549Q227 607 238 678Q240 694 251 694Q259 694 261 684Q261 677 265 659T284 608T320 549Q340 525 363 507T405 479T440 463T467 455T479 451Q483 447 483 433Q483 413 472 413Q467 413 458 416Q342 448 277 545L270 555V-179Q262 -193 252 -193H250H248Q236 -193 230 -179V555L223 545Q192 499 146 467T70 424T27 414Z"}})])])])]),_("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[_("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[_("mo",{attrs:{stretchy:"false"}},[v._v("↑")])],1)],1)],1)],1)]),v._v(" "),_("tr",[_("td",[v._v("字符串 2")]),v._v(" "),_("td",[v._v("Some sample text"),_("kbd",[v._v("NL")])])]),v._v(" "),_("tr",[_("td",[_("code",[v._v("$")]),v._v(" 能匹配的位置")]),v._v(" "),_("td",[_("del",[v._v("Some sample text")]),_("mjx-container",{staticClass:"MathJax",staticStyle:{direction:"ltr",position:"relative"},attrs:{jax:"SVG"}},[_("svg",{staticStyle:{overflow:"visible","min-height":"1px","min-width":"1px","vertical-align":"-0.437ex"},attrs:{xmlns:"http://www.w3.org/2000/svg",width:"1.131ex",height:"2.007ex",role:"img",focusable:"false",viewBox:"0 -694 500 887","aria-hidden":"true"}},[_("g",{attrs:{stroke:"currentColor",fill:"currentColor","stroke-width":"0",transform:"scale(1,-1)"}},[_("g",{attrs:{"data-mml-node":"math"}},[_("g",{attrs:{"data-mml-node":"mo"}},[_("path",{staticStyle:{"stroke-width":"3"},attrs:{"data-c":"2191",d:"M27 414Q17 414 17 433Q17 437 17 439T17 444T19 447T20 450T22 452T26 453T30 454T36 456Q80 467 120 494T180 549Q227 607 238 678Q240 694 251 694Q259 694 261 684Q261 677 265 659T284 608T320 549Q340 525 363 507T405 479T440 463T467 455T479 451Q483 447 483 433Q483 413 472 413Q467 413 458 416Q342 448 277 545L270 555V-179Q262 -193 252 -193H250H248Q236 -193 230 -179V555L223 545Q192 499 146 467T70 424T27 414Z"}})])])])]),_("mjx-assistive-mml",{staticStyle:{top:"0px",left:"0px",clip:"rect(1px, 1px, 1px, 1px)","-webkit-touch-callout":"none","-webkit-user-select":"none","-khtml-user-select":"none","-moz-user-select":"none","-ms-user-select":"none","user-select":"none",position:"absolute",padding:"1px 0px 0px 0px",border:"0px",display:"block",width:"auto",overflow:"hidden"},attrs:{unselectable:"on",display:"inline"}},[_("math",{attrs:{xmlns:"http://www.w3.org/1998/Math/MathML"}},[_("mo",{attrs:{stretchy:"false"}},[v._v("↑")])],1)],1)],1)],1)])])]),v._v(" "),_("p",[v._v("这时候，无论 "),_("kbd",[v._v("NL")]),v._v(" 是什么，是否存在，都可以用表达式 "),_("code",[v._v("\\w+$")]),v._v(" 匹配最后一个单词。")]),v._v(" "),_("p",[v._v("如果指定了多行模式，"),_("code",[v._v("$")]),v._v(" 会匹配每个行终止符之前的位置。最后一行的情况有点特殊：如果最后一行没有行终止符，则匹配字符串的结尾位置；否则，匹配行终止符之前的位置。")]),v._v(" "),_("p",[v._v("如果指定了多行模式，就可以用 "),_("code",[v._v("\\w+$")]),v._v(" 匹配每一行的最后一个单词了。")]),v._v(" "),_("p",[v._v("与 "),_("code",[v._v("$")]),v._v(" 类似的还有两个特殊标记 "),_("code",[v._v("\\Z")]),v._v(" 和 "),_("code",[v._v("\\z")]),v._v("，它们不受多行模式的影响，在任何情况下都匹配整个字符串的结束位置。"),_("code",[v._v("\\Z")]),v._v(" 和 "),_("code",[v._v("\\z")]),v._v(" 的主要差别在于："),_("code",[v._v("\\Z")]),v._v(" 等价于默认模式（非多行模式）下的 "),_("code",[v._v("$")]),v._v("，如果字符串的末尾有行终止符，则它匹配换行符之前的位置；"),_("code",[v._v("\\z")]),v._v(" 则不管行终止符，只匹配 "),_("strong",[v._v("整个字符串的结束位置")]),v._v("。")]),v._v(" "),_("p",[v._v("回过头来说 "),_("code",[v._v("^")]),v._v(" 和"),_("code",[v._v("$")]),v._v("，这两个锚点第 1 章介绍过，从数据校验的例子可以看到，"),_("code",[v._v("re.search(pattern,string)")]),v._v(" 只表示 "),_("code",[v._v("pattern")]),v._v(" 能否在 "),_("code",[v._v("string")]),v._v(" 中找到匹配，但是如果 "),_("code",[v._v("pattern")]),v._v(" 只匹配 "),_("code",[v._v("string")]),v._v(" 中的一部分，也不会返回 "),_("code",[v._v("None")]),v._v("；为了验证整个 "),_("code",[v._v("string")]),v._v(" 能否由 "),_("code",[v._v("pattern")]),v._v(" 匹配，通常的做法是在 "),_("code",[v._v("pattern")]),v._v(" 两端加上 "),_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v("，就像例 4-7 那样。")]),v._v(" "),_("p",[_("strong",[v._v("例 4-7 　借助 "),_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v(" 完成数据验证")])]),v._v(" "),_("p",[v._v("最常用到数据验证的场合就是对用户提交的数据进行验证，比如在网页上，要求用户在输入框（比如密码、邮箱）中填入某些信息，加以验证。一般来说，输入框中都不能输入换行符，但如果用户使用程序来提交，接收到的值就可能包含换行符。在这种情况下，在正则表达式两端添加 "),_("code",[v._v("^")]),v._v(" 和"),_("code",[v._v("$")]),v._v("是无法准确验证的，因为"),_("code",[v._v("$")]),v._v("可以匹配“结尾行终止符之前的位置”，验证时就忽略了末尾的行终止符。使用 "),_("code",[v._v("\\z")]),v._v(" 替换"),_("code",[v._v("$")]),v._v("可以堵住这个漏洞（使用 "),_("code",[v._v("\\z")]),v._v(" 时，最好把 "),_("code",[v._v("^")]),v._v(" 也替换成 "),_("code",[v._v("\\A")]),v._v("，这样更符合习惯，因为一般 "),_("code",[v._v("^")]),v._v(" 是和"),_("code",[v._v("$")]),v._v("成对出现的）。下面用 Python 为例说明这一点（因为 Python 不支持 "),_("code",[v._v("\\z")]),v._v("，但是 Python 中的 "),_("code",[v._v("\\Z")]),v._v(" 等价于其他语言中的 "),_("code",[v._v("\\z")]),v._v("，所以例 4-8 使用 "),_("code",[v._v("\\Z")]),v._v("）。")]),v._v(" "),_("p",[_("strong",[v._v("例 4-8 　借助 "),_("code",[v._v("\\A")]),v._v(" 和 "),_("code",[v._v("\\Z")]),v._v(" 完成更准确的数据验证")])]),v._v(" "),_("p",[v._v("类似 Python 中的 "),_("code",[v._v("\\Z")]),v._v("，JavaScript 中的 "),_("code",[v._v("$")]),v._v(" 的匹配也比较特殊，JavaScript 没有提供 "),_("code",[v._v("\\A")]),v._v("、"),_("code",[v._v("\\z")]),v._v("、"),_("code",[v._v("\\Z")]),v._v("，只有 "),_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v("，但是 JavaScript 中的 "),_("code",[v._v("$")]),v._v("，只能匹配字符串/行的结束位置，即便字符串末尾有换行符，也是如此，所以在验证时，可以放心使用 "),_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v("。JavaScript 代码见例 4-9。")]),v._v(" "),_("p",[_("strong",[v._v("例 4-9 　 JavaScript 中的验证")])]),v._v(" "),_("p",[_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v(" 的另一个特点是，进行正则表达式替换时并不会被替换。也就是说，在起始/结束位置进行替换，只会在起始/结束位置添加一些字符，位置本身仍然存在。使用这个特性，我们可以很方便地转换文本的格式。常见的应用是将纯文本转换为 HTML，比如将纯文本的电子文档转换成 ePub 格式，就需要如此处理。这个问题最简单的思路是，使用多行模式将 "),_("code",[v._v("^")]),v._v(" 替换为 "),_("code",[v._v("<p>")]),v._v("，将 "),_("code",[v._v("$")]),v._v(" 替换为 "),_("code",[v._v("</p>")]),v._v("，如例 4-10 所示，注意其中使用了多行模式，这样可以找到字符串内部文本行的开始和结束位置。")]),v._v(" "),_("p",[_("strong",[v._v("例 4-10 　"),_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v(" 的替换")])]),v._v(" "),_("p",[_("code",[v._v("^")]),v._v(" 和 "),_("code",[v._v("$")]),v._v(" 的另一个常用功能是删去多余的空白，包括行首尾的空白和空行。因为种种原因，要处理的文本可能经常包含许多空白字符，有些出现在行首，有些出现在行尾，还可能有不少空行。")]),v._v(" "),_("p",[v._v("如果要整理格式，需要删掉不必要的空白字符，但又不能把所有空白字符都删掉（单词与单词之间的空白字符应当保留）。所以要做的其实是删除行首和行尾的空白字符，我们先删除行首的空白字符，使用的正则表达式是 "),_("code",[v._v("(?m)^\\s+")]),v._v("。")]),v._v(" "),_("p",[v._v("这里必须使用多行模式，否则就只能删除整个字符串首尾的空白字符。另一方面，此处使用了量词 "),_("code",[v._v("+")]),v._v(" 而不是 "),_("code",[v._v("*")]),v._v("，因为 "),_("code",[v._v("^\\s*")]),v._v(" 可以不匹配任何字符，这样的“删除”没有意义。将 "),_("code",[v._v("(?m)^\\s+")]),v._v(" 匹配的文本替换为空字符串，就执行了删除操作（一般正则表达式应用中没有单独的“删除”操作，删除操作都是通过将文本替换为空字符串实现的）。例 4-11 展示了去除字符串行首空白字符的代码。")]),v._v(" "),_("p",[_("strong",[v._v("例 4-11 　去除行首的空白字符")])]),v._v(" "),_("p",[v._v("为方便观察，仍然用上面的方式显示字符串。")]),v._v(" "),_("p",[v._v("因为 "),_("code",[v._v("\\s")]),v._v(" 匹配的空白字符中包含换行符 "),_("code",[v._v("\\n")]),v._v("，所以完全是空白字符的第 3 行（连同换行符）也被删掉了。现在来删行尾的空格，使用表达式 "),_("code",[v._v("\\s+$")]),v._v("，同样要记得使用多行模式，如例 4-12 所示。")]),v._v(" "),_("p",[_("strong",[v._v("例 4-12 　去除行尾的空白字符")])]),v._v(" "),_("p",[v._v("仍然用上面的方式显示字符串。")]),v._v(" "),_("p",[v._v("能不能用多选结构 "),_("code",[v._v("(^\\s+|\\s+$)")]),v._v(" 并列两个表达式，一步完成呢？答案是 "),_("strong",[v._v("不能")]),v._v("。")]),v._v(" "),_("p",[v._v("不但第三行被删除，第二行和第四行也合并成一行，中间的 "),_("code",[v._v("\\t\\n\\n")]),v._v(" 全部被删除了，第二行末尾没有了换行符；而真正的目的其实只是想将 "),_("code",[v._v("\\t\\n\\n")]),v._v(" 替换为 "),_("code",[v._v("\\n")]),v._v("。仔细看看正则表达式 "),_("code",[v._v("(^\\s+|\\s+$)")]),v._v(" 就可以知道，在 "),_("code",[v._v("\\s+$")]),v._v(" 中，"),_("code",[v._v("\\s")]),v._v(" 可以匹配 "),_("code",[v._v("\\t")]),v._v(" 和 "),_("code",[v._v("\\n")]),v._v("，所以 "),_("code",[v._v("\\s+$")]),v._v(" 可以匹配开始的 "),_("code",[v._v("\\t\\n")]),v._v("，同样 "),_("code",[v._v("^\\s+")]),v._v(" 可以匹配结尾的 "),_("code",[v._v("\\n")]),v._v("，所以 "),_("code",[v._v("\\t\\n\\n")]),v._v(" 经过两步被彻底删除了。")]),v._v(" "),_("p",[v._v("这个例子所用的表达式很有意思，它提醒我们用多选结构合并多个表达式时，一定要小心未曾预期的后果；有时候，分几步进行反而能省去许多麻烦，这类例子在第 9 章还要讲到。")]),v._v(" "),_("h2",{attrs:{id:"前后查找"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#前后查找"}},[v._v("#")]),v._v(" 前后查找")]),v._v(" "),_("p",[v._v("“环视”是一个过于抽象的糟糕译名，不如“前后查找”（包括“向前查找”和“向后查找”）那么形象和具体。")]),v._v(" "),_("p",[v._v("到目前为止，我们见过的正则表达式都是用来匹配文本的，但有时我们还需要用正则表达式标记要匹配的文本的位置（而不仅仅是文本本身）。这就引出了前后查找（lookaround，对某一位置的前、后内容进行查找）的概念，我们将在这一章对此做专题讨论。")]),v._v(" "),_("p",[_("strong",[v._v("表 4-4 　前后查找的分类")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("名字")]),v._v(" "),_("th",[v._v("记法")]),v._v(" "),_("th",[v._v("判断方向")]),v._v(" "),_("th",[v._v("结构内表达式成功匹配的返回值")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("肯定向前查找")]),v._v(" "),_("td",[_("code",[v._v("(?=…)")])]),v._v(" "),_("td",[v._v("向右")]),v._v(" "),_("td",[_("code",[v._v("True")])])]),v._v(" "),_("tr",[_("td",[v._v("否定向前查找")]),v._v(" "),_("td",[_("code",[v._v("(?!…)")])]),v._v(" "),_("td",[v._v("向右")]),v._v(" "),_("td",[_("code",[v._v("False")])])]),v._v(" "),_("tr",[_("td",[v._v("肯定向后查找")]),v._v(" "),_("td",[_("code",[v._v("(?<=…)")])]),v._v(" "),_("td",[v._v("向左")]),v._v(" "),_("td",[_("code",[v._v("True")])])]),v._v(" "),_("tr",[_("td",[v._v("否定向后查找")]),v._v(" "),_("td",[_("code",[v._v("(?<!…)")])]),v._v(" "),_("td",[v._v("向左")]),v._v(" "),_("td",[_("code",[v._v("False")])])])])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("\\d+(?=PM)")]),v._v("：匹配类似于 "),_("code",[v._v("3PM")]),v._v(" 这样后面带 "),_("code",[v._v("PM")]),v._v(" 的时间数字 "),_("code",[v._v("3")])]),v._v(" "),_("li",[_("code",[v._v("\\d+(?!=PM)")]),v._v("：匹配一般的数字，但类似于 "),_("code",[v._v("3PM")]),v._v(" 这样后面带 "),_("code",[v._v("PM")]),v._v(" 的时间数字 "),_("code",[v._v("3")]),v._v(" 则不予匹配")]),v._v(" "),_("li",[_("code",[v._v("(?<=\\$)\\d+")]),v._v("：匹配类似于 "),_("code",[v._v("$5")]),v._v(" 这样前面带 "),_("code",[v._v("$")]),v._v(" 的数字 "),_("code",[v._v("5")])]),v._v(" "),_("li",[_("code",[v._v("(?<!\\$)\\d+")]),v._v("：匹配一般的数字，但类似于 "),_("code",[v._v("$5")]),v._v(" 这样前面带 "),_("code",[v._v("$")]),v._v(" 的数字 "),_("code",[v._v("5")]),v._v(" 则不匹配")])]),v._v(" "),_("blockquote",[_("p",[v._v("提示 有些正则表达式文档使用术语“消费”（consume）来表述“匹配和返回文本”的含义。在向前查找里，被匹配的文本不包含在最终返回的匹配结果里，这被称为“不消费”。")])])])}),[],!1,null,null,null);_.default=o.exports}}]);