(window.webpackJsonp=window.webpackJsonp||[]).push([[401],{750:function(v,_,e){"use strict";e.r(_);var o=e(4),c=Object(o.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[v._v("A "),_("strong",[v._v("capturing group")]),v._v(" groups a subpattern, allowing you to apply a quantifier to the entire group or use disjunctions within it. It memorizes information about the subpattern match, so that you can refer back to it later with a backreference, or access the information through the match results.")]),v._v(" "),_("p",[v._v("If you don't need the result of the subpattern match, use a non-capturing group instead, which improves performance and avoids refactoring hazards.")]),v._v(" "),_("p"),_("div",{staticClass:"table-of-contents"},[_("ul",[_("li",[_("a",{attrs:{href:"#分组"}},[v._v("分组")])]),_("li",[_("a",{attrs:{href:"#多选结构"}},[v._v("多选结构")])]),_("li",[_("a",{attrs:{href:"#引用分组"}},[v._v("引用分组")]),_("ul",[_("li",[_("a",{attrs:{href:"#反向引用"}},[v._v("反向引用")])]),_("li",[_("a",{attrs:{href:"#各种引用的记法"}},[v._v("各种引用的记法")])]),_("li",[_("a",{attrs:{href:"#命名分组"}},[v._v("命名分组")])])])]),_("li",[_("a",{attrs:{href:"#非捕获分组"}},[v._v("非捕获分组")])]),_("li",[_("a",{attrs:{href:"#补充"}},[v._v("补充")]),_("ul",[_("li",[_("a",{attrs:{href:"#转义"}},[v._v("转义")])]),_("li",[_("a",{attrs:{href:"#url-rewrite"}},[v._v("URL Rewrite")])]),_("li",[_("a",{attrs:{href:"#一个例子"}},[v._v("一个例子")])])])])])]),_("p"),v._v(" "),_("h2",{attrs:{id:"分组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#分组"}},[v._v("#")]),v._v(" 分组")]),v._v(" "),_("p",[v._v("用字符组和量词可以匹配引号字符串，也可以匹配 HTML tag，如果需要用正则表达式匹配身份证号码，依靠字符组和量词能不能做到呢？")]),v._v(" "),_("p",[v._v("身份证号码的特点：\n是一个长度为 15 或 18 个字符的字符串，如果是 15 位，则全部由数字组成，首位不能为 0；如果是 18 位，前 17 位全部是数字，首位同样不能是 0，末位可能是数字，也可能是字母 x。")]),v._v(" "),_("p",[v._v("尝试写出的正则表达式是 "),_("code",[v._v("[1-9]\\d{13,16}[0-9x]")])]),v._v(" "),_("p",[v._v("看来，果然能够匹配各种形式的身份证号码，应该没问题。不过这还不够，这个正则表达式应该保证身份证号码的字符串能够匹配，其他字符串不能够匹配。")]),v._v(" "),_("p",[v._v("这两个字符串分明不是身份证号码（第一个是 16 位长，第二个虽然是 15 位长，但末尾是 "),_("code",[v._v("x")]),v._v("），却都匹配了。这是为什么呢？仔细观察所用的正则表达式，会发现两点原因：第一，"),_("code",[v._v("\\d{13,16}")]),v._v(" 表示除去首尾两位，中间的部分长度可能在 13~16 之间，而不是“长度要么为 13，要么为 16”；第二，最后的 "),_("code",[v._v("[0-9x]")]),v._v(" 只应该对应 18 位身份证号码的情况，但是在这个表达式中，它也可以对应到 15 位身份证号码，而 15 位身份证号码的末位是不能为 "),_("code",[v._v("x")]),v._v(" 的！")]),v._v(" "),_("p",[v._v("虽然字符串的长度是可变的，但是除去第一位和最后一位，中间部分的长度必须明确指定，只能是 13 或者 16，而不能使用量词 "),_("code",[v._v("{13,16}")]),v._v("；另外，末尾一位到底是 "),_("code",[v._v("[0-9]")]),v._v("（也就是 "),_("code",[v._v("\\d")]),v._v("）还是 "),_("code",[v._v("[0-9x]")]),v._v("，取决于长度—如果长度是 15 位，则是 "),_("code",[v._v("\\d")]),v._v("；如果长度是 18 位，则是 "),_("code",[v._v("[0-9x]")]),v._v("。两种情况分别考虑，要更加清楚一些。")]),v._v(" "),_("p",[v._v("看来，只要以 15 位号码的匹配为基础，末尾加上可能出现的 "),_("code",[v._v("\\d{2}[0-9x]")]),v._v(" 即可。最后的 "),_("code",[v._v("\\d{2}[0-9x]")]),v._v(" 必须作为一个整体，或许不出现（15 位号码），或许出现（18 位号码）。量词 "),_("code",[v._v("?")]),v._v(" 可以表示“不出现，或者出现 1 次”，正好合适。")]),v._v(" "),_("p",[v._v("但是，正则表达式 "),_("code",[v._v("\\d{2}[0-9x]?")]),v._v(" 是不行的，因为量词 "),_("code",[v._v("?")]),v._v(" 只能限定 "),_("code",[v._v("[0-9x]")]),v._v(" 的出现，而正则表达式 "),_("code",[v._v("\\d{2}?[0-9x]?")]),v._v(" 同样不行—即使只出现一个 "),_("code",[v._v("[0-9x]")]),v._v("，也可以匹配。到底怎样才能把 "),_("code",[v._v("\\d{2}[0-9x]")]),v._v(" 作为一个整体呢？")]),v._v(" "),_("p",[v._v("答案是：使用括号 "),_("code",[v._v("(…)")]),v._v("，把正则表达式改写为 "),_("code",[v._v("[1-9]\\d{14}(\\d{2}[0-9x])?")]),v._v("。上一章提到过，量词限定之前元素的出现，这个元素可能是一个字符，也可能是一个字符组，还可能是一个表达式—如果把一个表达式用括号包围起来，这个元素就是括号里的表达式，括号内的表达式通常被称为 "),_("strong",[v._v("子表达式")]),v._v("（sub-expression）。所以，"),_("code",[v._v("(\\d{2}[0-9x])?")]),v._v(" 就表示子表达式 "),_("code",[v._v("\\d{2}[0-9x]")]),v._v(" 作为一个整体，或许不出现，或许最多出现一次。")]),v._v(" "),_("p",[v._v("括号的这种功能叫作 "),_("strong",[v._v("分组")]),v._v("（grouping）。如果用量词限定出现次数的元素不是字符或者字符组，而是连续的几个字符甚至子表达式，就应该用括号将它们“编为一组”。比如，希望字符串 "),_("code",[v._v("ab")]),v._v(" 重复出现一次以上，就应该写作 "),_("code",[v._v("(ab)+")]),v._v("，此时 "),_("code",[v._v("(ab)")]),v._v(" 成为一个整体，由量词 "),_("code",[v._v("+")]),v._v(" 来限定；如果不用括号而直接写 "),_("code",[v._v("ab+")]),v._v("，受 "),_("code",[v._v("+")]),v._v(" 限定的就只有 "),_("code",[v._v("b")]),v._v("。")]),v._v(" "),_("p",[v._v("有了分组，就可以准确表示“长度只能是 m 或 n”。比如在上面匹配身份证号码的例子中，要匹配一个长度为 13 或者 16 的数字字符串。常犯的错误是使用表达式 "),_("code",[v._v("\\d{13,16}")]),v._v("，看起来没问题，但长度为 14 或 15 的数字字符串同样会匹配。真正准确的做法是：首先匹配长度为 13 的数字字符串，然后匹配可能出现的长度为 3 的数字字符串，正则表达式就成了 "),_("code",[v._v("\\d{13}(\\d{3})?")]),v._v("。")]),v._v(" "),_("p",[v._v("分组是非常有用的功能，因为使用正则表达式时经常会遇到并没有直接相连，但确实存在联系的部分，分组可以把这些概念上相关的部分“归拢”到一起，以免割裂，下面来看几个例子。")]),v._v(" "),_("p",[v._v("第 2 章使用表达式 "),_("code",[v._v("<[^/][^>]*>")]),v._v(" 匹配 HTML 中的 open tag，比如 "),_("code",[v._v("<table>")]),v._v("，但是这个表达式也会匹配 self-closing tag，比如 "),_("code",[v._v("<br />")]),v._v("。如果把表达式改为 "),_("code",[v._v("<[^/][^>]*[^/]>")]),v._v("，确实可以避免匹配 self-closing tag，但是因为两个排除型字符组要匹配两个字符，这个表达式又会漏过 "),_("code",[v._v("<u>")]),v._v(" 之类的 open tag，仅仅依靠字符组和量词无法配合解决问题，必须动用括号的分组功能。")]),v._v(" "),_("p",[_("code",[v._v("<[^/][^>]*[^/]>")]),v._v(" 错过的只有一种情况，就是 tag name 为单个字母的情况。如果 tag name 不是单个字母，则第一个字母之后，必然会出现这样一个字符串：其中不包含 "),_("code",[v._v(">")]),v._v("，结尾的字符并不是 "),_("code",[v._v("/")]),v._v("。最后，才是 tag 结尾的 "),_("code",[v._v(">")]),v._v("。像图 3-1 所示那样，将这几个元素拆开，能看得更清楚点。")]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("标签")]),v._v(" "),_("th",[v._v("内容")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("单字符 tag")]),v._v(" "),_("td",[_("code",[v._v("<")]),v._v(" "),_("code",[v._v("u")]),v._v(" "),_("code",[v._v(">")])])]),v._v(" "),_("tr",[_("td",[v._v("多字符 tag")]),v._v(" "),_("td",[_("code",[v._v("<")]),v._v(" "),_("code",[v._v("t")]),v._v(" "),_("code",[v._v("able")]),v._v(" "),_("code",[v._v(">")])])]),v._v(" "),_("tr",[_("td",[v._v("表达式")]),v._v(" "),_("td",[_("code",[v._v("<")]),v._v(" "),_("code",[v._v("[^/]")]),v._v(" "),_("code",[v._v("[^>]*[^/]")]),v._v(" "),_("code",[v._v(">")])])]),v._v(" "),_("tr",[_("td"),v._v(" "),_("td",[v._v("必须出现  可选出现  必须出现")])])])]),v._v(" "),_("p",[_("strong",[v._v("图 3-1　open tag 的准确匹配")])]),v._v(" "),_("p",[v._v("所以，用一个括号将可选出现的部分分组，再用量词 "),_("code",[v._v("?")]),v._v(" 限定，就可以得到兼顾这两种情况、准确匹配 open tag 的正则表达式了，程序代码如例 3-5 所示。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-5　准确匹配 open tag")]),v._v("\n[插图]")]),v._v(" "),_("p",[v._v("再来看一个更复杂的例子。在 Web 服务中，经常并不希望暴露真正的程序细节，所以用某种模式的 URL 来掩盖。比如这个 URL："),_("code",[v._v("/foo/bar_qux.php")]),v._v("，看起来是访问一个 PHP 页面，其实背后有复杂的路由规则。真正的结构如图 3-2 所示，"),_("code",[v._v("foo")]),v._v(" 是模块的名称，"),_("code",[v._v("bar")]),v._v(" 是控制器的名字，"),_("code",[v._v("qux")]),v._v(" 则是方法名，三个名字中都只能出现小写字母。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[_("strong",[v._v("图 3-2　URL 的结构")])]),v._v(" "),_("p",[v._v("希望能处理的情况有三种，其他情况都不予考虑。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("为编写通用的正则表达式来匹配，有些人是这么总结的。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("所以正则表达式就是："),_("code",[v._v("/[a-z]+/?[a-z]*_?[a-z]*(\\.php)?")]),v._v("。")]),v._v(" "),_("p",[v._v("仔细看看这个表达式，无论是 "),_("code",[v._v("/foo")]),v._v("，还是 "),_("code",[v._v("/foo/bar.php")]),v._v("，抑或是 "),_("code",[v._v("/foo/bar_qux.php")]),v._v("，都可以匹配，看起来确实没有问题。")]),v._v(" "),_("p",[v._v("可是，这个表达式中只有 "),_("code",[v._v("/[a-z]+")]),v._v(" 是必须出现的，其他部分都是“不一定出现”的，也就是说，其中任意一个或几个部分出现，这个表达式都可以匹配。那么，"),_("code",[v._v("/foo/_")]),v._v(" 也是可以匹配的，"),_("code",[v._v("/foo.php")]),v._v(" 也是可以匹配的，这样就乱套了，如例 3-6 所示。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-6　URL 匹配的表达式")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("之所以会出错，根源在于有些元素是“不一定出现”的，但它们之间却是有关联的：“不一定出现”的几个元素虽然没有前后紧密相连，却是“同生共死”的关系。这时候就要梳理清楚逻辑关系，用括号的分组功能把各种分支情况归拢到一起。")]),v._v(" "),_("p",[_("code",[v._v("/foo")]),v._v(" 是必须出现的，之后存在两种可能："),_("code",[v._v("/bar.php")]),v._v(" 或者 "),_("code",[v._v("/bar_qux.php")]),v._v("。在前一种情况中，开头的 "),_("code",[v._v("/")]),v._v("、控制器名 "),_("code",[v._v("bar")]),v._v("、结尾的 "),_("code",[v._v(".php")]),v._v(" 是必须出现的；在后一种情况中，开头的 "),_("code",[v._v("/")]),v._v("、控制器名 "),_("code",[v._v("bar")]),v._v("、下画线 "),_("code",[v._v("_")]),v._v("、模块名 "),_("code",[v._v("qux")]),v._v("、结尾的 "),_("code",[v._v(".php")]),v._v(" 是必须出现的。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("仔细观察这两个表达式，会发现它们可以合并：把第二个表达式中多出的部分，继续用分组括号配合量词 "),_("code",[v._v("?")]),v._v(" 表示，塞到第一个表达式中，用得到的表达式配合量词 "),_("code",[v._v("?")]),v._v(" 再加上最开头“必须出现”的 "),_("code",[v._v("/foo")]),v._v("，最后得到完整的表达式。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("从例 3-7 可以看到，这个表达式确实杜绝了错误的匹配。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-7　杜绝了错误匹配的表达式")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("关于括号的分组功能，最后来看 E-mail 地址的匹配：E-mail 地址以 "),_("code",[v._v("@")]),v._v(" 分隔为两段，"),_("code",[v._v("@")]),v._v(" 之前的是用户名（username），之后的是主机名（hostname），用户名一般只允许出现数字和字母（现在有些邮件服务商也允许用户名中出现点号等字符了，这种情况复杂一些，此处不做考虑），而主机名则是类似 "),_("code",[v._v("mail.google.com")]),v._v("、"),_("code",[v._v("mail.163.com")]),v._v(" 之类的字符串。")]),v._v(" "),_("p",[v._v("用户名的匹配非常简单，其中能出现的字符主要有大写字母 "),_("code",[v._v("[A-Z]")]),v._v("、小写字母 "),_("code",[v._v("[a-z]")]),v._v("、阿拉伯数字字符 "),_("code",[v._v("[0-9]")]),v._v("，下画线 "),_("code",[v._v("_")]),v._v("、点号 "),_("code",[v._v(".")]),v._v("，所以总的字符组就是 "),_("code",[v._v("[A-Za-z0-9_.]")]),v._v("，又可以简化为 "),_("code",[v._v("[\\w.]")]),v._v("；另一方面，用户名的最大长度是 64 个字符，所以匹配用户名的正则表达式就是 "),_("code",[v._v("[\\w.]{1,64}")]),v._v("。")]),v._v(" "),_("p",[v._v("主机名匹配的情况则要麻烦一些，简单的情况比如 "),_("code",[v._v("somehost.com")]),v._v("；复杂的情况则还包括子域名，比如 "),_("code",[v._v("mail.somehost.net")]),v._v("，而且子域名可能不只一级，比如 "),_("code",[v._v("mail.sub.somehost.net")]),v._v("。查阅规范可知，主机名被点号分隔为若干段，叫作域名字段（label），每个域名字段中能出现的字符是字母字符、数字字符和横线字符，长度必须在 1~63 之间。下面看几个例子，尝试从中找到主机名的规律。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("看来规律是这样的：最后的域名字段是顶级域名 [2]，之前的部分可以看作某种模式的重复：该模式由域名字段和点号组成，域名字段在前，点号在后。比如 "),_("code",[v._v("somehost.com")]),v._v(" 就可以这么看：顶级域名是 "),_("code",[v._v("com")]),v._v("，之前是 "),_("code",[v._v("somehost.")]),v._v("；"),_("code",[v._v("sub.somehost.net")]),v._v(" 就可以这么看：顶级域名是 "),_("code",[v._v("net")]),v._v("，之前是 "),_("code",[v._v("sub.")]),v._v(" 和 "),_("code",[v._v("somehost.")]),v._v("。\n匹配域名字段的表达式是 "),_("code",[v._v("[-a-zA-Z0-9]{1,63}")]),v._v("，匹配点号的表达式是 "),_("code",[v._v("\\.")]),v._v("，使用括号的分组功能，把这两个表达式分为一组，用量词 "),_("code",[v._v("*")]),v._v(" 限定表示“不出现，或出现多次”，就得到匹配主机名的表达式 "),_("code",[v._v("([-a-zA-Z0-9]{1,63}\\.)*[-a-zA-Z0-9]{1,63}")]),v._v("（因为顶级域名也是一个域名字段，所以即便主机名是 localhost，也可以由最后那个匹配域名字段的表达式匹配）。")]),v._v(" "),_("p",[v._v("将匹配用户名的表达式、"),_("code",[v._v("@")]),v._v(" 符号、匹配主机名的表达式组合起来，就得到了完整的匹配 E-mail 地址的表达式："),_("code",[v._v("[-\\w.]{0,64}@([-a-zA-Z0-9]{1,63}\\.)*[-a-zA-Z0-9]{1,63}")]),v._v("，这个表达式的匹配情况如例 3-8 所示。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-8　完整匹配 E-mail 地址的正则表达式")]),v._v("\n[插图]")]),v._v(" "),_("h2",{attrs:{id:"多选结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#多选结构"}},[v._v("#")]),v._v(" 多选结构")]),v._v(" "),_("p",[v._v("之前用表达式 "),_("code",[v._v("[1-9]\\d{14}(\\d{2}[0-9x])?")]),v._v(" 匹配身份证号，思路是把 18 位号码多出的 3 位“合并”到匹配 15 位号码的表达式中。这样写没有错，只是得花点心思才能理解其逻辑。")]),v._v(" "),_("p",[v._v("能不能直接分情况处理呢？15 位身份证号就是 "),_("code",[v._v("[1-9]")]),v._v(" 开头，之后是 14 位数字；18 位身份证号就是 "),_("code",[v._v("[1-9]")]),v._v(" 开头，之后是 16 位数字，最后是 "),_("code",[v._v("[0-9x]?")]),v._v("。只要两个表达式中的一个能够匹配，就是合法的身份证号，这样的思路更加清晰。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("答案是可以的，而且仍然使用括号解决问题，只是要用到括号的另一个功能："),_("strong",[v._v("多选结构")]),v._v("（alternative）。")]),v._v(" "),_("p",[v._v("多选结构的形式是 "),_("code",[v._v("(…|…)")]),v._v("，在括号内以竖线 "),_("code",[v._v("|")]),v._v(" 分隔开多个子表达式，这些子表达式也叫 "),_("strong",[v._v("多选分支")]),v._v("（option）；在一个多选结构内，多选分支的数目没有限制。在匹配时，整个多选结构被视为单个元素，只要其中某个子表达式能够匹配，整个多选结构的匹配就能成功；如果所有子表达式都不能匹配，则整个多选结构匹配失败。")]),v._v(" "),_("p",[v._v("回到身份证号码匹配的例子，既然可以区分 15 位和 18 位两种情况，就可以将每种情况对应的表达式作为一个分支，“合并”为多选结构 "),_("code",[v._v("([1-9]\\d{14}|[1-9]\\d{14}\\d{2}[0-9x])")]),v._v("。这个表达式的匹配如例 3-9 所示，它同样可以准确验证身份证号码。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-9　用多选结构匹配身份证号码")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("多选结构在实际中经常用到，匹配 IP 地址就是如此：IP 地址（暂不考虑 IPv6）分为 4 段（4 字节），每段都是 8 位二进制数，换算成常见的十进制，取值在 0~255 之间，中间以点号 "),_("code",[v._v(".")]),v._v(" 分隔。点号 "),_("code",[v._v(".")]),v._v(" 的匹配非常容易，用 "),_("code",[v._v("\\.")]),v._v(" 就可以，所以暂且忽略它，只考虑匹配这个数值的问题，而且因为 4 段 IP 地址的取值范围是相同的，只考虑其中一段的匹配即可。")]),v._v(" "),_("p",[v._v("要匹配十进制形式的 IP 地址，最常见的正则表达式就是 "),_("code",[v._v("[0-9]{1,3}")]),v._v("，也就是 1~3 位十进制数字。粗看起来，这个表达式没什么错，细看却有很大问题。因为 256、999 这样的数值，显然不在 0~255 之间，却可以由 "),_("code",[v._v("[0-9]{1,3}")]),v._v(" 匹配。")]),v._v(" "),_("p",[v._v("细致一点的表达式似乎是 "),_("code",[v._v("[0-2][0-5][0-5]")]),v._v("，这样就限制了数值只能在 "),_("code",[v._v("255")]),v._v(" 以内……不过，仔细想想，因为限定了第二位（十位）和第三位（个位）都只能出现 0~5 之间的字符，表达式没法匹配 "),_("code",[v._v("168")]),v._v(" 之类的数值。\n其实，问题可以这样解决：先用表达式匹配这个字符串，再将它转换为整数类型的变量 "),_("code",[v._v("x")]),v._v("，判断 "),_("code",[v._v("x")]),v._v(" 是否在 0 到 255 之间："),_("code",[v._v("0<=x&&x<=255")]),v._v("。没错，这确实是一个解决问题的思路，只是有点麻烦，最好能用正则表达式“一次性”搞定这个问题。仔细想想就能发现，正则表达式虽然不能直接表示“匹配一段数值在 0~255 之间的文本”，但可以分几种情况描述这样的文本。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("虽然不如 "),_("code",[v._v("0<=x&&x<=255")]),v._v(" 判断简便，但如果文本符合其中任何一条规则（或者说，只要其中任何一个正则表达式能匹配），就可以判断它为“表示数字的数值在 0~255 之间”。用多选结构把这几条规则对应的表达式合并起来，就得到了表达式 "),_("code",[v._v("([0-9]|[0-9]{2}|1[0-9][0-9]|2[0-4][0-9]|25[0-5])")]),v._v("，它的匹配如例 3-10 所示。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-10　准确匹配 0~255 之间的字符串")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("如果要更完善一点，能识别 030、005 这样的数值，可以修改对应的子表达式，为一位数和两位数的情况增加之前可能出现 0 的匹配，得到表达式 "),_("code",[v._v("((00)?[0-9]|0?[0-9]{2}|1[0-9][0-9]|2[0-4][0-9]|25[0-5])")]),v._v("。")]),v._v(" "),_("p",[v._v("上面讲解的其实是用正则表达式匹配数值在某个范围内的字符串的通用模式，它很重要，因为许多时候会遇到类似的任务，比如匹配月（1~12）、日（不考虑只有 30 天的情况，粗略记为 1~31）、小时（0~24）、分钟（00~60）的正则表达式，用正则表达式解决这类问题，会用到同样的模式。")]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("这个模式还可以用于匹配手机号码：手机号码通常是 11 位，前面 3 位是号段，目前有 130~139 号段　、150~153、155~156、180、182、185~189 号段，　用多选分支 "),_("code",[v._v("(13[0-9]|15[0-356]|18[025-9])")]),v._v(" 可以很准确地匹配号段；之后的 8 位一般没有限制，只要是数字即可，用 "),_("code",[v._v("\\d{8}")]),v._v(" 匹配。另外，手机号码开头可能有 "),_("code",[v._v("0")]),v._v(" 或者 "),_("code",[v._v("+86")]),v._v("，它可以用 "),_("code",[v._v("(0|\\+86)")]),v._v(" 匹配，因为整个部分是可能出现的，所以需要加上量词，也就是 "),_("code",[v._v("(0|\\+86)?")]),v._v("，最后得到的正则表达式就是 "),_("code",[v._v("(0|\\+86)?(13[0-9]|15[0-356]|18[025-9])\\d{8}")]),v._v("。")]),v._v(" "),_("p",[v._v("多选结构还可以解决更复杂的问题，比如上一章的 tag 匹配问题，当时使用的表达式是 "),_("code",[v._v("<[^>]+>")]),v._v("。一般来说，这个表达式是没有问题的，但也有可能 tag 内部还是会出现 "),_("code",[v._v(">")]),v._v(" 符号，比如 "),_("code",[v._v('<input name=txt value=">">')]),v._v("。这类问题使用字符组解决不了，可以使用多选结构解决。")]),v._v(" "),_("p",[v._v("仔细分析 tag 中可能出现 "),_("code",[v._v(">")]),v._v("，它只可能作为属性（"),_("code",[v._v("attribute")]),v._v("）出现在单引号字符串和双引号字符串中，根据 HTML 规范，引号字符串中不能出现嵌套转义的引号，所以单引号字符串可以用 "),_("code",[v._v("'[^']*'")]),v._v(" 来匹配，双引号字符串可以用 "),_("code",[v._v('"[^"]*"')]),v._v(" 来匹配，相应的，其他内容可以用 "),_("code",[v._v("[^'\">]")]),v._v(" 来匹配，所以更完善的表达式是 "),_("code",[v._v("<('[^']*'|\"[^\"]*\"|[^'\">])+>")]),v._v("。它的匹配情况见例 3-11。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-11　准确的 HTML tag 匹配")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("请注意其中的量词，因为单引号字符串和双引号字符串都可以是空字符串，比如 "),_("code",[v._v("alt=''")]),v._v(" 或 "),_("code",[v._v('alt=""')]),v._v("，所以匹配其中文本的内容使用 "),_("code",[v._v("*")]),v._v("；而 "),_("code",[v._v("[^'\">]")]),v._v(" 则没有使用量词，因为它存在于多选结构内部，多选结构外部有 "),_("code",[v._v("+")]),v._v(" 量词限制，保证了它不只是匹配一个字符。如果在多选结构内部使用 "),_("code",[v._v("[^'\">]*")]),v._v("，虽然看来似乎没错，却可能导致非常奇怪的结果，不过现在不用关心，在第 143 页会给出详细讲解。")]),v._v(" "),_("p",[v._v("关于多选结构，最后还要补充三点。")]),v._v(" "),_("p",[v._v("第一，多选结构的一般表示法是 "),_("code",[v._v("(option1|option2)")]),v._v("（其中 option1 和 option2 是两个作为多选分支的正则表达式），在多选结构中一般会同时使用括号 "),_("code",[v._v("()")]),v._v(" 和竖线 "),_("code",[v._v("|")]),v._v("；但是如果没有括号 "),_("code",[v._v("()")]),v._v("，只出现竖线 "),_("code",[v._v("|")]),v._v("，仍然是多选结构。从例 3-12 可以看到，"),_("code",[v._v("ab|cd")]),v._v(" 既可以匹配 "),_("code",[v._v("ab")]),v._v("，也可以匹配 "),_("code",[v._v("cd")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-12　没有括号的多选结构")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("在多选结构中，竖线 "),_("code",[v._v("|")]),v._v(" 用来分隔多选结构，而括号 "),_("code",[v._v("()")]),v._v(" 用来规定整个多选结构的范围，如果没有出现括号，则将整个表达式视为一个多选结构，所以 "),_("code",[v._v("ab|cd")]),v._v(" 等价于 "),_("code",[v._v("(ab|cd)")]),v._v("。如果在某些地方看到没有括号的多选结构，你不用奇怪。")]),v._v(" "),_("p",[v._v("不过，我还是推荐明确写出两端的括号，这样更形象，也能避免一些错误。如果你仔细看，就会发现在上面的表达式中，并没有使用 "),_("code",[v._v("^")]),v._v(" 和"),_("code",[v._v("$")]),v._v("定位字符串的起始位置和结束位置，按道理说，加上之后应该匹配更加准确，结果却并非如此。")]),v._v(" "),_("p",[v._v("因为竖线 "),_("code",[v._v("|")]),v._v(" 的优先级很低，所以 "),_("code",[v._v("^ab|cd$")]),v._v(" 其实是 "),_("code",[v._v("(^ab|cd$)")]),v._v("，而不是 "),_("code",[v._v("^(ab|cd)$")]),v._v("，它的真正意思是“字符串开头的 "),_("code",[v._v("ab")]),v._v(" 或者字符串结尾的 "),_("code",[v._v("cd")]),v._v("”，而不是“只包含 "),_("code",[v._v("ab")]),v._v(" 或 "),_("code",[v._v("cd")]),v._v(" 的字符串”，代码见例 3-13。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-13　没有括号的多选结构")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("第二，多选分支并不等于字符组。多选分支看起来类似字符组，如 "),_("code",[v._v("[abc]")]),v._v(" 能匹配的字符串和 "),_("code",[v._v("(a|b|c)")]),v._v(" 一样，"),_("code",[v._v("[0-9]")]),v._v(" 能匹配的字符串和 "),_("code",[v._v("(0|1|2|3|4|5|6|7|8|9)")]),v._v(" 一样。从理论上说，可以完全用多选结构来替换字符组，但这种做法并不推荐，理由在于：首先，"),_("code",[v._v("[abc]")]),v._v(" 比 "),_("code",[v._v("(a|b|c)")]),v._v(" 要简洁许多，在多选结构中的每个分支都必须明确写出，不能使用 "),_("code",[v._v("-")]),v._v(" 范围表示法，"),_("code",[v._v("(0|1|2|3|4|5|6|7|8|9)")]),v._v(" 比 "),_("code",[v._v("[0-9]")]),v._v(" 麻烦很多；其次，在大多数情况下，"),_("code",[v._v("[abc]")]),v._v(" 比 "),_("code",[v._v("(a|b|c)")]),v._v(" 的效率要高很多。所以，能用字符组解决的问题，最好不要用多选结构。")]),v._v(" "),_("p",[v._v("反过来，多选结构不一定能对应到字符组。因为字符组的每个“分支”的长度相同，而且只能是单个字符；而多选结构的每个“分支”的长度没有限制，甚至可以是复杂的表达式，比如 "),_("code",[v._v("(abc|b+c*ab)")]),v._v("，字符组完全无能为力。")]),v._v(" "),_("p",[v._v("多选分支和字符组的另一点重要区别（同时也是常犯的错误）是：排除型字符组可以表示“无法由某几个字符匹配的字符”，多选结构却没有对应的结构表示“无法由某几个表达式匹配的字符串”。从例 3-14 可以看到，"),_("code",[v._v("[^abc]")]),v._v(" 表示“匹配除 a、b、c 之外的任意字符”，"),_("code",[v._v("(^a|b|c)")]),v._v(" 却不能表示“匹配除 a、b、c 之外的任意字符串”。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-14　多选结构不能表示“无法由某几个表达式匹配的字符串”")])]),v._v(" "),_("p",[v._v("在实际开发中确实可能遇到这种需求，不过它没有现成的解法。如果你现在就希望匹配“无法由某几个表达式匹配的字符串”，请翻到第 148 页。")]),v._v(" "),_("p",[v._v("第三，多选分支的排列是有讲究的。比如这个表达式 "),_("code",[v._v("(jeff|jeffrey)")]),v._v("，用它匹配 "),_("code",[v._v("jeffrey")]),v._v("，结果到底是 "),_("code",[v._v("jeff")]),v._v(" 还是 "),_("code",[v._v("jeffrey")]),v._v(" 呢？这个问题并没有标准的答案，本书介绍的 Java、.NET、Python、Ruby、JavaScript、PHP 中，多选结构都会优先选择最左侧的分支。这一点从例 3-15 看得很清楚：如果使用的字符串是 "),_("code",[v._v("jeffrey")]),v._v("，正则表达式是 "),_("code",[v._v("(jeff|jefferey)")]),v._v(" 还是 "),_("code",[v._v("(Jeffrey|jeff)")]),v._v("，结果是不一样的（此处仅以 Python 为例，本书中介绍的其他语言中的结果与此相同）。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-15　多选结构的匹配顺序")])]),v._v(" "),_("p",[v._v("在实际开发中可能会遇到这样的情况：统计一段文本中，“湖南”和“湖南省”分别出现的次数。如果直接查找“湖南”，可能会将“湖南省”中的“湖南”也找出来，如果使用多选结构 "),_("code",[v._v("(湖南省|湖南)")]),v._v("，就可以一次性找出所有“湖南”和“湖南省”，再按照字符串的长度分别计数，就可以得到两者出现的次数了。")]),v._v(" "),_("p",[v._v("不过，"),_("code",[v._v("(湖南省|湖南)")]),v._v(" 只是一个针对特殊应用的例子。在平时使用中，如果出现多选结构，应当尽量避免多选分支中存在重复匹配，因为这样会大大增加回溯的计算量。也就是说，应当避免这样的情况：针对多选结构 "),_("code",[v._v("(option1|option2)")]),v._v("，某段文本既可以由 "),_("code",[v._v("option1")]),v._v(" 匹配，也可以由 "),_("code",[v._v("option2")]),v._v(" 匹配。如果出现了这样的多选结构，效率可能会受到极大影响（第 168 页总结了可能影响效率的几种写法），尤其在受量词限定的多选结构中更是如此：一般人很难遇到 "),_("code",[v._v("(a|[ab])")]),v._v(" 这类多选结构，但 "),_("code",[v._v("([0-9]|\\w)")]),v._v(" 之类则一不留神就会遇到。")]),v._v(" "),_("h2",{attrs:{id:"引用分组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#引用分组"}},[v._v("#")]),v._v(" 引用分组")]),v._v(" "),_("p",[v._v("括号不仅能把有联系的元素归拢起来并分组，还有其他的作用—使用括号之后，正则表达式会保存每个分组真正匹配的文本，等到匹配完成后，通过 "),_("code",[v._v("group(num)")]),v._v(" 之类的方法“引用”分组在匹配时捕获的内容（这个方法之前已经出现过）。其中，"),_("code",[v._v("num")]),v._v(" 表示对应括号的编号，括号分组的编号规则是从左向右计数，从 "),_("code",[v._v("1")]),v._v(" 开始。因为“捕获”了文本，所以这种功能叫作 "),_("strong",[v._v("捕获分组")]),v._v("（capturing group）。对应的，这种括号叫作 "),_("strong",[v._v("捕获型括号")]),v._v("。")]),v._v(" "),_("p",[v._v("前面我们看到了引用分组，了解到能引用某个分组内的子表达式匹配的文本，但引用都是在匹配完成后进行的，能不能在正则表达式中引用呢？")]),v._v(" "),_("p",[v._v("答案是可以的，下面就引出 "),_("strong",[v._v("编号分组")]),v._v(" 和 "),_("strong",[v._v("命名分组")]),v._v(" 两种方法。")]),v._v(" "),_("ul",[_("li",[v._v("编号分组 Numbering groups")]),v._v(" "),_("li",[v._v("命名分组 Named groups")])]),v._v(" "),_("h3",{attrs:{id:"反向引用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反向引用"}},[v._v("#")]),v._v(" 反向引用")]),v._v(" "),_("p",[v._v("答案是可以的，这种功能被称作 "),_("strong",[v._v("反向引用")]),v._v("（back-reference），也译作 "),_("strong",[v._v("回溯引用")]),v._v("，它允许在正则表达式内部引用之前的捕获分组匹配的文本（也就是左侧），其形式也是 "),_("code",[v._v("\\num")]),v._v("，其中 "),_("code",[v._v("num")]),v._v(" 表示所引用分组的编号，编号规则与之前介绍的相同。")]),v._v(" "),_("p",[v._v("在 VS Code 里面，正则表达式应该是 ECMAJavaScript (JavaScript) 风格，反向引用的形式是 "),_("code",[v._v("$num")]),v._v("，不再是 "),_("code",[v._v("\\num")]),v._v("。")]),v._v(" "),_("p",[v._v("根据反向引用，查找连续重叠字母的表达式就是 "),_("code",[v._v("([a-z])\\1")]),v._v("，其中的 "),_("code",[v._v("[a-z]")]),v._v(" 匹配第一个字母，再用括号将匹配分组，然后用 "),_("code",[v._v("\\1")]),v._v(" 来反向引用。")]),v._v(" "),_("p",[v._v("在日常开发中，我们可能经常需要反向引用来建立前后联系。最常见的例子就是解析 HTML 代码时匹配 tag。之前我们说过，tag 包括 open tag 和 close tag, open tag 和 close tag 经常是成对出现的，比如 "),_("code",[v._v("<bold>text</bold>")]),v._v(" 或 "),_("code",[v._v("<h1>title</h1>")]),v._v("。")]),v._v(" "),_("p",[v._v("有了反向引用功能，就可以先匹配 open tag，再匹配其他内容，直到最近的 close tag 为止：在匹配 open tag 时，用一个括号分组匹配 tag name 的表达式 "),_("code",[v._v("([^>]+)")]),v._v("；在匹配 close tag 时，用 "),_("code",[v._v("\\1")]),v._v(" 引用之前匹配的 tag name，就完成了配对（要注意的是，这里需要用到忽略优先量词 "),_("code",[v._v("*?")]),v._v("，否则可能会出现错误匹配，理由在第 2 章匹配 JavaScript 代码时讲过）。最后得到的表达式就是 "),_("code",[v._v("<([^>]+)>[\\s\\S]*?</\\1>")]),v._v("。")]),v._v(" "),_("p",[v._v("也有些 tag 更复杂一点，比如 "),_("code",[v._v('<span class="class1">text</span>')]),v._v("，在 tag 名之后有一个空白字符，然后是其他属性，此时原有的表达式就无法匹配了。为应对这类情况，应当修改表达式，让分组 1 准确匹配 tag name，它可以是数字、小写字母、大写字母，所以将它修改为 "),_("code",[v._v("<([a-zA-Z0-9]+)\\s[^>]+>[\\s\\S]*?<\\1>")]),v._v("，但满足了 "),_("code",[v._v("\\s[^>]+")]),v._v(" 的匹配，就无法应对之前的那些 open tag。为了兼容两种情况，必须用括号分组和量词 "),_("code",[v._v("?")]),v._v(" 来限定，也就是改为 "),_("code",[v._v("(\\s[^>]+)?")]),v._v("，最后的表达式就是 "),_("code",[v._v("<([a-zA-Z0-9]+)(\\s[^>]+)?>[\\s\\S]*?</\\1>")]),v._v("。")]),v._v(" "),_("p",[v._v("反向引用还可以用在其他很多地方，比如在处理中文文本时，用它很容易找出“浩浩荡荡”“清清白白”之类 AABB，或者“如火如荼”、“越快越好”之类 AXAY 类型的四字词语。")]),v._v(" "),_("p",[v._v("关于反向引用，还有一点需要强调：反向引用重复的是对应捕获分组匹配的文本，而不是之前的表达式；也就是说，反向引用是一种“引用”，对应的是由之前表达式决定的具体文本，它本身并不规定文本的特征。这一点，新手常犯错误。")]),v._v(" "),_("p",[v._v("仍然以匹配 IP 地址为例，前面说过，IP 地址分 4 段（4 字节），匹配其中每一段的表达式是 "),_("code",[v._v("(0{0,2}[0-9]|0?[0-9]{2}|1[0-9][0-9]|2[0-4][0-9]|25[0-5])")]),v._v("，之间用点号 "),_("code",[v._v(".")]),v._v(" 分隔，所以匹配完整 IP 地址的表达式应该用量词重复这个子表达式，而不是用反向引用重复这个表达式匹配的文本。例 3-27 对比了这两个表达式，其中第二个表达式中使用了反向引用，故而要求后面 3 段与第 1 个字段完全一样，所以它只能匹配 8.8.8.8 之类的地址，而不能匹配 192.168.0.1 之类地址。")]),v._v(" "),_("h3",{attrs:{id:"各种引用的记法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#各种引用的记法"}},[v._v("#")]),v._v(" 各种引用的记法")]),v._v(" "),_("p",[v._v("根据前面的介绍，对分组的引用可能出现在三种场合：在匹配完成后，用 "),_("code",[v._v("group(num)")]),v._v(" 之类的方法提取数据；在进行正则表达式替换时，用 "),_("code",[v._v("\\num")]),v._v(" 引用；在正则表达式内部，用 "),_("code",[v._v("\\num")]),v._v(" 引用。")]),v._v(" "),_("p",[v._v("不过，这只是 Python 语言的规定，事情并不总是如此："),_("code",[v._v("group(num)")]),v._v(" 之类的方法，在各种语言中都是差不多的；但是在有些语言中，替换时引用的记法和正则表达式内部引用的记法是不同的。表 3-2 总结了各种常用语言中的两类记法。")]),v._v(" "),_("p",[_("strong",[v._v("表 3-2　各种语言中引用分组的记法")])]),v._v(" "),_("table",[_("thead",[_("tr",[_("th",[v._v("语言")]),v._v(" "),_("th",[v._v("表达式中的反向引用")]),v._v(" "),_("th",[v._v("替换中的反向引用")])])]),v._v(" "),_("tbody",[_("tr",[_("td",[v._v("Python")]),v._v(" "),_("td",[_("code",[v._v("\\num")])]),v._v(" "),_("td",[_("code",[v._v("\\num")])])])])]),v._v(" "),_("p",[v._v("看起来 "),_("code",[v._v("\\num")]),v._v(" 和 "),_("code",[v._v("$num")]),v._v(" 差别不大："),_("code",[v._v("\\1")]),v._v(" 或者 "),_("code",[v._v("$1")]),v._v(" 表示第 1 个捕获分组，"),_("code",[v._v("\\2")]),v._v(" 或者 "),_("code",[v._v("$2")]),v._v(" 表示第 2 个捕获分组……不过一般来说，"),_("code",[v._v("$num")]),v._v(" 要好于 "),_("code",[v._v("\\num")]),v._v("。原因在于，"),_("code",[v._v("$0")]),v._v(" 可以准确表示“第 0 个分组（也就是整个表达式匹配的文本）”，而 "),_("code",[v._v("\\0")]),v._v(" 则不行，因为在不少语言的字符串中，"),_("code",[v._v("\\num")]),v._v(" 本身是一个有意义的转义序列，它表示值为 "),_("code",[v._v("num")]),v._v(" 的 ASCII 字符，所以 "),_("code",[v._v("\\0")]),v._v(" 会被解释为“ASCII 编码为 0 的字符”。但是反向引用不存在这个问题，因为不能在正则表达式还没匹配结束时，就用 "),_("code",[v._v("\\0")]),v._v(" 引用整个表达式匹配的文本。")]),v._v(" "),_("p",[v._v("但无论是 "),_("code",[v._v("\\num")]),v._v(" 还是 "),_("code",[v._v("$num")]),v._v("，都有可能遇到二义性的问题：如果出现了 "),_("code",[v._v("\\10")]),v._v("( 或者 "),_("code",[v._v("$10")]),v._v("，这里以 "),_("code",[v._v("\\num")]),v._v(" 为例），它到底表示第 10 个捕获分组 "),_("code",[v._v("\\10")]),v._v("，还是第 1 个捕获分组 "),_("code",[v._v("\\1")]),v._v(" 之后跟着一个字符 "),_("code",[v._v("0")]),v._v("？Python 的结果见例 3-28。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-28　可能具有二义性的反向引用")])]),v._v(" "),_("p",[v._v("原来 "),_("code",[v._v("\\10")]),v._v(" 会被解释成“第 10 个捕获分组匹配的文本”，而不是“第 1 个捕获分组匹配的文本之后加上字符 0”。如果我们就是希望做到后面这步，Python 提供了 "),_("code",[v._v("\\g<num>")]),v._v(" 表示法，将 "),_("code",[v._v("\\10")]),v._v(" 写成 "),_("code",[v._v("\\g<1>0")]),v._v("，这样同时也避免了替换时无法使用 "),_("code",[v._v("\\0")]),v._v(" 的问题，代码如例 3-29 所示。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-29　使用 "),_("code",[v._v("g<n>")]),v._v(" 消除二义性")])]),v._v(" "),_("div",{staticClass:"language-python line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-python"}},[_("code",[v._v("In "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("1")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("import")]),v._v(" re\n\nIn "),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("[")]),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("2")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("]")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(":")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token keyword"}},[v._v("print")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),v._v("re"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(".")]),v._v("sub"),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v("(")]),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('r"(\\d)"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('r"\\g<1>0"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(",")]),v._v(" "),_("span",{pre:!0,attrs:{class:"token string"}},[v._v('"123456"')]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),_("span",{pre:!0,attrs:{class:"token punctuation"}},[v._v(")")]),v._v("\n"),_("span",{pre:!0,attrs:{class:"token number"}},[v._v("102030405060")]),v._v("\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br"),_("span",{staticClass:"line-number"},[v._v("3")]),_("br"),_("span",{staticClass:"line-number"},[v._v("4")]),_("br")])]),_("h3",{attrs:{id:"命名分组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#命名分组"}},[v._v("#")]),v._v(" 命名分组")]),v._v(" "),_("p",[v._v("在日常工作中，编号分组和回溯引用的通用性更好一些，使用更为广泛。命名分组的书写形式因语言各不相同，比如 Java 里面的形式是 "),_("code",[v._v("(?:<name>RE)")]),v._v("，跟 Python 里面的写法就不同；命名分组回溯引用时的书写形式又是另外一种形式，有较高的记忆成本，所以使用相对较少。简单了解即可，等有了具体的应用，再查阅相关资料。")]),v._v(" "),_("p",[v._v("捕获分组通常用数字编号来标识，但这样有几个问题：数字编号不够直观，虽然规则是“从左向右按照开括号出现的顺序计数”，但括号多了难免混淆；引用时也不够方便，上面已经讲过 "),_("code",[v._v("\\10")]),v._v(" 引起混淆的情况。")]),v._v(" "),_("p",[v._v("为解决这类问题，一些语言和工具提供了 "),_("strong",[v._v("命名分组")]),v._v("（named grouping），可以将它看作另一种捕获分组，但是标识是容易记忆和辨别的名字，而不是数字编号。")]),v._v(" "),_("p",[v._v("命名分组的记法也并不复杂。在 Python 中用 "),_("code",[v._v("(?P<name>regex)")]),v._v(" 来分组的，其中的 "),_("code",[v._v("name")]),v._v(" 是赋予这个分组的名字，"),_("code",[v._v("regex")]),v._v(" 则是分组内的正则表达式。这样，匹配年月日的正则表达式中，可以给年、月、日的分组分别命名，再用 "),_("code",[v._v("group(name)")]),v._v(" 来获得对应分组匹配的文本。图 3-5 说明了命名分组的结构，具体的代码见例 3-32。")]),v._v(" "),_("p",[_("strong",[v._v("图 3-5　命名分组")])]),v._v(" "),_("p",[_("strong",[v._v("例 3-32　命名分组捕获")])]),v._v(" "),_("p",[v._v("因为数字编号分组的历史更长，为保证向后兼容性，即便使用了命名分组，每个命名分组同时也具有数字编号，其编号规则没有变化。从例 3-33 可以看到，在全部使用命名分组的情况下，仍然可以使用数字编号来引用分组。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-33　命名分组捕获时仍然保留了数字编号")])]),v._v(" "),_("p",[v._v("在 Python 中，如果在表达式的前半部分使用了命名分组 "),_("code",[v._v("(?P<name>regex)")]),v._v("，在表达式的后半部分中反向引用时，必须使用 "),_("code",[v._v("(?P=name)")]),v._v(" 的记法；而要进行正则表达式替换，则需要写作 "),_("code",[v._v("\\g<name>")]),v._v("，其中的 "),_("code",[v._v("name")]),v._v(" 是分组的名字。代码见例 3-34. The "),_("code",[v._v("(?P=<name>)")]),v._v(" metacharacter sequence is a backreference, similar to "),_("code",[v._v("\\<n>")]),v._v(", except that it refers to a named group rather than a numbered group.")]),v._v(" "),_("p",[_("strong",[v._v("例 3-34　命名分组的引用方法")])]),v._v(" "),_("h2",{attrs:{id:"非捕获分组"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#非捕获分组"}},[v._v("#")]),v._v(" 非捕获分组")]),v._v(" "),_("p",[v._v("到目前为止，总共介绍了括号的三种用途：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("分组")]),v._v("，将相关的元素归拢到一起，构成单个元素")]),v._v(" "),_("li",[_("strong",[v._v("多选结构")]),v._v("，规定可能出现的多个子表达式")]),v._v(" "),_("li",[_("strong",[v._v("引用分组")]),v._v("，将子表达式匹配的文本存储起来，供之后引用")])]),v._v(" "),_("p",[v._v("这三种用途并不是彼此独立的，而是互相重叠的：单纯的分组可以视为“只包含一个多选分支的多选结构”；整个多选结构也会被视为单个元素，可以由单个量词限定。最重要的是，无论是否需要引用分组，只要出现了括号，正则表达式在匹配时就会把括号内的子表达式存储起来，提供引用。如果并不需要引用，保存这些信息无疑会影响正则表达式的性能；如果表达式比较复杂，要处理的文本又很多，更可能严重影响性能。")]),v._v(" "),_("p",[v._v("为解决这种问题，正则表达式提供了 "),_("strong",[v._v("非捕获分组")]),v._v("（non-capturing group），非捕获分组类似普通的捕获分组，只是在开括号后紧跟一个问号和冒号 "),_("code",[v._v("(?:… )")]),v._v("，这样的括号叫作 "),_("strong",[v._v("非捕获型括号")]),v._v("，它只能限定量词的作用范围，不捕获任何文本。在引用分组时，分组的编号同样会按开括号出现的顺序从左到右递增，只是必须以捕获分组为准，会略过非捕获分组，如例 3-35 所示。"),_("code",[v._v("(?:<regex>)")]),v._v(" is just like "),_("code",[v._v("(<regex>)")]),v._v(" in that it matches the specified "),_("code",[v._v("<regex>")]),v._v(". But "),_("code",[v._v("(?:<regex>)")]),v._v(" doesn』t capture the match for later retrieval.")]),v._v(" "),_("p",[_("strong",[v._v("例 3-35　非捕获分组的使用")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("p",[v._v("非捕获分组不需要保存匹配的文本，整个表达式的效率也因此提高，但是看起来不如捕获分组美观，所以很多人不习惯这种记法。不过，如果只需要使用括号的分组或者多选结构的功能，而没有用到引用分组，则应当尽量使用非捕获型括号。")]),v._v(" "),_("p",[v._v("如果不习惯这种记法，比较好的办法是，在写正则表达式时先统一使用捕获分组，确保正确之后，再把不需要引用的分组改为非捕获分组—当然，引用分组的编号可能也要调整（在上例中，只需要取月份信息，把第一个分组改为非捕获分组之后，取月份信息对应分组的编号从 2 变为 1）。")]),v._v(" "),_("p",[v._v("在本文中，为了使代码简洁和易于阅读，除非特殊标注，否则不管匹配完成之后是否会引用文本，都使用捕获分组。")]),v._v(" "),_("h2",{attrs:{id:"补充"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[v._v("#")]),v._v(" 补充")]),v._v(" "),_("h3",{attrs:{id:"转义"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#转义"}},[v._v("#")]),v._v(" 转义")]),v._v(" "),_("p",[v._v("之前讲到，如果元字符是单个出现的，直接添加反斜线字符转义即可，所以 "),_("code",[v._v("*")]),v._v("、"),_("code",[v._v("+")]),v._v("、"),_("code",[v._v("?")]),v._v(" 的转义形式分别是 "),_("code",[v._v("\\*")]),v._v("、"),_("code",[v._v("\\+")]),v._v("、"),_("code",[v._v("\\?")]),v._v("。如果元字符是成对出现的，则有可能只对第一个字符转义，比如 "),_("code",[v._v("{6}")]),v._v(" 和 "),_("code",[v._v("[a-z]")]),v._v(" 的转义分别是 "),_("code",[v._v("\\{6}")]),v._v(" 和 "),_("code",[v._v("\\[a-z]")]),v._v("。")]),v._v(" "),_("p",[v._v("括号的转义与它们都不同，与括号有关的所有三个元字符 "),_("code",[v._v("(")]),v._v("、"),_("code",[v._v(")")]),v._v("、"),_("code",[v._v("|")]),v._v(" 都必须转义。因为括号非常重要，所以无论是开括号还是闭括号，只要出现，正则表达式就会尝试寻找整个括号，如果只转义了开括号而没有转义闭括号，一般会报告“括号不匹配”的错误。另一方面，多选结构中的 "),_("code",[v._v("|")]),v._v(" 也必须转义（多选结构可以不用括号只出现 "),_("code",[v._v("|")]),v._v("），所以，也不要忘记对 "),_("code",[v._v("|")]),v._v(" 的转义，否则就可能出现例 3-36 的问题。")]),v._v(" "),_("p",[_("strong",[v._v("例 3-36　括号的转义")])]),v._v(" "),_("p",[v._v("[插图]")]),v._v(" "),_("h3",{attrs:{id:"url-rewrite"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#url-rewrite"}},[v._v("#")]),v._v(" URL Rewrite")]),v._v(" "),_("h3",{attrs:{id:"一个例子"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一个例子"}},[v._v("#")]),v._v(" 一个例子")]),v._v(" "),_("p",[v._v("这部分内容来自一位朋友的问题，这个问题相当有迷惑性和代表性，所以不妨列在这里，希望能解开更多读者的类似疑惑。")]),v._v(" "),_("p",[v._v("问题是这样的：运行 "),_("code",[v._v("re.findall('(\\w+\\.?)+','aaa.bbb.ccc')")]),v._v("，期望得到序列 "),_("code",[v._v("aaa.")]),v._v("、"),_("code",[v._v("bbb.")]),v._v("、"),_("code",[v._v("ccc")]),v._v("，实际运行的结果却只有 "),_("code",[v._v("ccc")]),v._v("，这是为什么呢？")]),v._v(" "),_("p",[v._v("其实答案很简单—因为表达式 "),_("code",[v._v("(\\w+\\.?)+")]),v._v(" 中存在量词 "),_("code",[v._v("+")]),v._v("，所以在整个正则表达式的匹配过程中，括号内的 "),_("code",[v._v("\\w+\\.?")]),v._v(" 会多次匹配：第 1 次匹配 "),_("code",[v._v("aaa.")]),v._v("，第 2 次匹配 "),_("code",[v._v("bbb.")]),v._v("，第 3 次（也就是最后）匹配 "),_("code",[v._v("ccc")]),v._v("，最终这个捕获分组匹配的文本就是 "),_("code",[v._v("ccc")]),v._v("。调用 "),_("code",[v._v("re.findall()")]),v._v(" 时，因为存在括号（也就是捕获分组），默认返回捕获分组匹配的文本，也就是 "),_("code",[v._v("ccc")]),v._v("。")]),v._v(" "),_("p",[v._v("解答了这个问题之后，他继续问：如果字符串是 "),_("code",[v._v("aaa.bbb")]),v._v("，或者 "),_("code",[v._v("aaa.bbb.ccc.ddd")]),v._v("，如何能用一个表达式，逐个拆分出 "),_("code",[v._v("aaa.")]),v._v("、"),_("code",[v._v("bbb.")]),v._v(" 之类的子串呢？（请注意，子串的个数是变化的，并且不能预先知道。 )")]),v._v(" "),_("p",[v._v("要搞清楚这个问题，需要记住：捕获分组的个数是不能动态变化的—单个正则表达式里有多少个捕获分组，一次匹配成功之后，结果中就必然存在多少个对应的元素（捕获分组匹配的文本）。如果不能预先规定匹配结果中元素的个数，就不能使用捕获分组。如果要匹配数目不定的多段文本，必须通过重复多次匹配完成。具体到这个例子，在 "),_("code",[v._v("re.findall('\\w+\\.?','aaa.bbb.ccc')")]),v._v(" 中，整个正则表达式会匹配成功 3 次，得到 3 个子串；如果把字符串改为 "),_("code",[v._v("aaa.bbb.ccc.ddd")]),v._v("，则整个正则表达式会匹配成功 4 次，得到 4 个子串。")])])}),[],!1,null,null,null);_.default=c.exports}}]);